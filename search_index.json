[["index.html", "R for Data Science Book Club Welcome", " R for Data Science Book Club The R4DS Online Learning Community 2021-12-05 Welcome This is a companion for the book R for Data Science by Hadley Wickham and Garrett Grolemund. This companion is available at r4ds.io/r4ds. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["introduction-preface.html", "Chapter 1 Introduction (Preface)", " Chapter 1 Introduction (Preface) The preface gives an overview of what the book covers. Learning objectives: Describe a typical data science project. Explain the reasoning behind the order of content in this book. Recognize topics that are explicitly not covered by this book. Set up an environment in which you can learn the topics in this book. Describe how code in the book differs from code in your console. Recall ways to get help with R code. Produce a minimal reproducible example or reprex. "],["a-typical-data-science-project.html", "1.1 A typical data science project", " 1.1 A typical data science project The data science process Import: Get a data from a file, database, or web app into R. Tidy: Make sure each column in your data is a variable and each row in your data is an observeration. Transform: Filter your data to specific observations, mutate existing columns into new columns, and summarize data. Visualize: Visualization is an important component of data exploration, but usually isn‚Äôt very useful for automated processes. Model: Once you know what you‚Äôre asking, you can use a model to answer those questions. Models tend to scale well. Communicate: Communication is a critical part of data science! It doesn‚Äôt matter how good your models are if nobody knows about them. Program: Programming can aid the entire process, and unlock things that wouldn‚Äôt be possible to determine by hand. "],["the-order-of-content-in-this-book.html", "1.2 The order of content in this book", " 1.2 The order of content in this book Import &amp; Tidy are boring, so we jump to visualization &amp; transformation. After that we learn to wrangle (import &amp; tidy) data, because that is a necessary skill. Those baseline skills enables us to start programming. Learning to program helps us simplify the other steps. We might then get into modeling and communicating, or we might pick those up in books that are more specifically devoted to those skills. "],["not-covered-by-this-book.html", "1.3 Not covered by this book", " 1.3 Not covered by this book Big data: Working with big data is problem-specific. If you need to work with big data, other tools will be useful to learn. Python, Julia, etc: This book focuses on R. Master one tool at a time, but maybe go on to other tools later. Non-rectangular data: Honestly even a lot of things that aren‚Äôt naturally table-like can be coerced to be table-like, so it makes sense to start with tables. Hypothesis confirmation: This book focuses on exploratory data analysis. "],["setting-up-an-environment.html", "1.4 Setting up an environment", " 1.4 Setting up an environment We‚Äôll need: R Rstudio The tidyverse (install.packages(\"tidyverse\")) Three additional packages (install.packages(c(\"nycflights13\", \"gapminder\", \"Lahman\"))) "],["running-r-code.html", "1.5 Running R code", " 1.5 Running R code Code in the book has some slight differences from code on your console. Don‚Äôt freak out. "],["getting-help.html", "1.6 Getting help", " 1.6 Getting help Pay attention to error messages. tidyverse error messages tend to actually be helpful. If you can‚Äôt figure out what an error is telling you, copy/paste it into Google. Stackoverflow.com can be helpful, but beware. r4ds.io/join is a friendly Slack community with volunteer R tutors. When you ask for help, make a reprex if possible. State up front what packages you use (we‚Äôll learn about loading packages very soon). Provide (a subset of) any data you use with dput(). Make sure your code is easy to read. Use clean spacing, clear variable names, and comments. #rstats twitter is super active and surprisingly friendly. "],["meeting-videos.html", "1.7 Meeting Videos", " 1.7 Meeting Videos 1.7.1 Cohort 1 Meeting chat log 00:18:00 Morgan Grovenburg: I have to leave early today. Also, I&#39;d normally have my video on, but my kid is currently using me as a jungle gym 00:21:19 Susie Neilson: Link to our team‚Äôs work :) https://www.sfchronicle.com/data/ 00:22:40 Morgan Grovenburg: I know what talk you&#39;re talking about 00:23:10 Wai-Yin: Data journalism‚Äôs wikipedia article https://en.wikipedia.org/wiki/Data_journalism 00:49:59 Ryan Metcalf: Great question Susie! I consider ‚ÄúBig Data‚Äù anything I can‚Äôt open in a conventional service. Using scripting languages helps with managing overhead (Cost [not monetary], time of process, processing capability, etc‚Ä¶). 01:00:14 Njoki Njuki Lucy: data.table has the similar syntax as the base R package. 01:17:46 Jon Harmon (jonthegeek): r4ds.io/r4ds "],["introduction.html", "Chapter 2 Introduction", " Chapter 2 Introduction In this section, we‚Äôll learn about: Data visualization Data transformation Exploratory data analysis Workflows to organize our thoughts "],["data-visualisation.html", "Chapter 3 Data visualisation", " Chapter 3 Data visualisation Learning objectives: ‚ÄúThe fundamental principles or rules of an art or science‚Äù OED Online 1989 Data visualisation: learning the basic structure of a ggplot2 plot Data transformation: select, filter, create, and summarize Exploratory data analysis: combination of visualisation and transformation In the next chapters we will see how modeling is an important part of the exploratory process and focus on R workflow. Learning objectives: Load the tidyverse family of packages Produce a simple plot with {ggplot2} Use aesthetic mappings to produce more complex plots Deal with common R programming problems. Produce small multiples with facet() Combine multiple geom_*() objects to produce more complex plots Recognize the interaction between stats and geoms Use the position argument to control data layout. Use alternative coordinate systems for plots in ggplot2 Describe the components of the layered grammar of graphics "],["loading-packages-in-r.html", "3.1 Loading Packages in R", " 3.1 Loading Packages in R Use install.packages(\"PACKAGE_NAME\") to install a package in R. You need to do this before you can use a package, but you only need to do it once. Depending where you‚Äôre learning R, the packages you need may already be installed. Use library(PACKAGE_NAME) to load a package in R. In general, you want to do this at the start of any session where you use a package. Alternatively, you can refer to a package every time you use it, such as ggplot2::ggplot(). ‚Äúggplot2‚Äù is the package, ‚Äúggplot()‚Äù is the function call, ‚Äú::‚Äù tells R ‚Äúlook up this function in this package.‚Äù library(tidyverse) ## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ ## ‚úî ggplot2 3.3.5 ‚úî purrr 0.3.4 ## ‚úî tibble 3.1.6 ‚úî dplyr 1.0.7 ## ‚úî tidyr 1.1.4 ‚úî stringr 1.4.0 ## ‚úî readr 2.1.1 ‚úî forcats 0.5.1 ## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ ## ‚úñ dplyr::filter() masks stats::filter() ## ‚úñ dplyr::lag() masks stats::lag() "],["first-steps.html", "3.2 First Steps", " 3.2 First Steps 3.2.1 How to visualise your data using ggplot2 ‚Äúggplot2 is a plotting system for R, based on the grammar of graphics, which tries to take the good parts of base and lattice graphics and none of the bad parts. It takes care of many of the fiddly details that make plotting a hassle (like drawing legends) as well as providing a powerful model of graphics that makes it easy to produce complex multi-layered graphics.‚Äù ¬© Hadley Wickham 2013 The {ggplot2} package is one of the {tidyverse} packages, it lets us build up plots layer by layer. Figure 3.1: ggplot2 package The layered grammar of graphics: to see the structure of a ggplot() ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot(data = &lt;DATA&gt;): Set up a base plot with data &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)): Add a geometry, such as a point (geom_point()) mapping: Map visual properties (x, y) to variables from data (displ, hwy) aes(): A function to do the mapping. The name is short for ‚Äúaesthetics.‚Äù Spoiler alert: ‚Äúaesthetics‚Äù is the word Hadley uses for ‚Äúvisual properties‚Äù Other little things brought out here: Type ?FUNCTION_NAME (`?) to load help for that function (or data object) All {tidyverse} help is also available at tidyverse.org Exercises solution are available at: jrnold.github.io/r4ds-exercise-solutions After having loaded the library you can start building your plot. Let‚Äôs start with making an empty plot: ggplot() + geom_blank() The ggplot() function can be used by adding data inside the function as its first argument, and adding a mapping as a second argument: ggplot( data = &lt; some data &gt; , mapping = aes( x = x , y = y )) + &lt;GEOM_FUNCTION&gt;() "],["geometry.html", "3.3 Geometry", " 3.3 Geometry There are several different types of of &lt;GEOM_FUNCTION&gt;: geom_ point (scatterplot) line smooth histogram / bar or (stat_count) / col boxplot map text ‚Ä¶ "],["aesthetic-mappings.html", "3.4 Aesthetic mappings", " 3.4 Aesthetic mappings Aesthetics are visual properties of objects in the plot. There are several different types of of aesthetic mapping: coordinates: x and y size shape color fill alpha (transparency) stroke linetype group show.legend others, sometimes specific to a geom Use the mapping argument and the aes function to map an aesthetic to a variable in data. Or assign the in the ggplot() function and the mapping in one of the : ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) As an example we load the data provided in {ggplot2}: ggplot2::mpg Display the data head of the first 3 rows: head(mpg,3) ## # A tibble: 3 √ó 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa‚Ä¶ ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa‚Ä¶ ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa‚Ä¶ Add a to ggplot(&lt;DATA&gt;) with: ggplot(data=mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) Here the color appears outside the mapping but what if it will be set inside of it? A super common error: Trying to set the color inside the aes call results in random effects because aes() automatically figures out the necessary scale for your data. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;)) "],["common-problems.html", "3.5 Common problems", " 3.5 Common problems What is very important when deciding on a visualization of your data? Before you create your visualization, you need to have your data ready. We‚Äôll learn more about these steps in upcoming chapters:``` import your data tidy the data to have your variables ready to display transform the data as needed visualize the data with a plot model communicate One more suggestion would be to sketch down your visualization before hand and then set the data ready and plot it! More tips: The {tidyverse} (the packages described in this book) tend to have really good error messages. Pay attention to what they say! Read the help at ?function_name to see if maybe it doesn‚Äôt work how you thought it worked Googling error messages can often help Take a deep breath. You‚Äôve got this! Get practice doing some TidyTuesdays "],["other-function-and-features.html", "3.6 Other function and features", " 3.6 Other function and features Facets Statistical transformations Position adjustments Coordinate systems Themes 3.6.1 Facets They never use this terminology, but‚Ä¶ you can subgroup your visualization with a facet_ function: Small multiples: Multiple plots on the same axes comparing something across splits in a dataset There are 2 versions of this function in ggplot2: facet_wrap() the variable that you pass to facet_wrap() should be discrete facet_grid() the formula should contain two variable names separated by a ~ ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) You can either use ~ or vars() 3.6.2 Statistical transformations Lots of geoms use transformed data. For example, geom_bar(aes(x = cut)) calculates a count for each cut. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) stat_*() functions do this calculation. ?stat_count (etc) has a Computer variables section that tells you what that stat computes. You can use these computed variables to make fancier plots. 3.6.3 Position adjustments Geoms have a position argument to tell it how to deal with things that go on top of one another. Sample values include ‚Äústack‚Äù, ‚Äúidentity‚Äù, ‚Äúfill‚Äù, ‚Äúdodge‚Äù, and ‚Äújitter‚Äù. geom_jitter() is a shortcut for geom_point(position = \"jitter\") because it‚Äôs super useful. dat &lt;- tibble( x = rep(1:3, 3), y = rep(1:3, 3) ) ggplot(dat, aes(x, y)) + geom_point() ggplot(dat, aes(x, y)) + geom_jitter() Use width and height arguments of geom_jitter to more specifically specify range. ggplot(dat, aes(x, y)) + geom_jitter(width = 0.1, height = 0.5) 3.6.4 Coordinate systems Add Coordinate systems to your ggplot with: coord_flip() coord_quickmap() coord_polar() coord_fixed() By default, {ggplot} uses coord_cartesian() but you can add other functions: coord_flip() can be useful to quickly flip orientations (although this is less necessary in modern {ggplot} than when this book was written; now there‚Äôs an ‚Äúorientation‚Äù argument that is usually guessed properly if you leave it blank) coord_quickmap() does proper transformations to work with lat/long data. coord_polar() for circular plots, which are almost always a bad idea but they tend to look cool coord_fixed() set the same limits to both axis 3.6.5 Theme Once your data are imported, tidied and transformed adeguately for obtaing desired visualization you can start setting up a plot with extra features: ?theme It is possible to add a theme() function to your ggplot, this is done to customize the non-data components of your plots: titles labels fonts background gridlines legends ‚Ä¶ For example if you would like to customize the background of your plot: ggplot() + geom_blank() + theme(plot.background = element_rect(color = &quot;red&quot;, size = 2, fill = &quot;gold&quot;), panel.background = element_rect(color = &quot;grey&quot;, size = 5, fill = &quot;darkblue&quot;)) Or you can customize a theme_, there are many different themes provided by defauld by ggplo2 such as: theme_classic() theme_minimal() theme_void() just to name a few, those function then can be further customize by adding the theme customization function. "],["to-summarize-the-gg-in-ggplot.html", "3.7 To summarize: The gg in {ggplot}", " 3.7 To summarize: The gg in {ggplot} {ggplot} implements the ‚Äúlayered grammar of graphics.‚Äù ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; + &lt;THEME_FUNCTION&gt; + theme() ggplot(data = &lt;DATA&gt;): Set up a base plot with data. &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)): Add a geometry, such as a point (geom_point()). mapping: Map aesthetics (x, y) to variables from data (displ, hwy). stat: How to transform the data. aes(): A function to do the mapping. The name is short for ‚Äúaesthetics.‚Äù position: How to deal with things that overlap. &lt;COORDINATE_FUNCTION&gt;: Adjust the coordinate layout. &lt;FACET_FUNCTION&gt;: Break the plot up into small multiples. In addition it is possible to subset data inside the ggplot() function or inside the &lt;GEOM_FUNCTION&gt;(): ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE) R4DS book 3.7.1 Exercises: R for Data Science: Exercise Solutions 3.7.2 Resources: A Layered Grammar of Graphics {ggplot2} ggplot2 extensions - gallery R Graphics Cookbook "],["meeting-videos-1.html", "3.8 Meeting Videos", " 3.8 Meeting Videos 3.8.1 Cohort 1 Meeting chat log 00:11:14 Jon Harmon (jonthegeek): r4ds.io/r4ds 00:12:06 Saeed Shafiei Sabet: Hi everyone! 00:12:29 Sandra Muroy: Hi Saeed! 00:13:05 Becki R. (she/her): Hello! 00:13:30 Sandra Muroy: Hi Becki! 00:22:41 Saeed Shafiei Sabet: Can also by using ggplot2 do some 3D surface plots? 00:24:01 shamsuddeen: https://ggplot2.tidyverse.org/reference/geom_contour.html 00:24:12 shamsuddeen: 2D contours of a 3D surface 00:25:34 Saeed Shafiei Sabet: Thanks @shamsuddeen ;) 00:25:50 Jon Harmon (jonthegeek): ggplot2 is 2D. There are other packages for 3D visualization, I&#39;ll try to link some in your question on the Slack once we&#39;re done! 00:26:29 Saeed Shafiei Sabet: @Jon Thanks a lot! :) 00:26:34 shamsuddeen: I guess this package provides 3D plotting https://www.rayshader.com/index.html 00:27:24 Jon Harmon (jonthegeek): Yup, that&#39;s the one I was going to recommend: https://cran.r-project.org/web/packages/rayshader/index.html 00:28:28 Jon Harmon (jonthegeek): I found it super helpful to figure out how to read some of these things as words: %&gt;% = &quot;and then&quot; ~ = &quot;by&quot; (usually) 00:28:30 shamsuddeen: Looks at some practical examples of the package here: https://www.tylermw.com/3d-ggplots-with-rayshader/ 00:29:54 Saeed Shafiei Sabet: Thank you! 00:36:02 docksbox@pm.me: https://jrnold.github.io/r4ds-exercise-solutions/ 00:40:57 Jon Harmon (jonthegeek): ?ggplot2::mpg will show all the details of the dataset 00:41:50 Sandra Muroy: thanks Jon :) 00:42:40 Jon Harmon (jonthegeek): hwy = &quot;highway miles per gallon&quot;, cty = &quot;city miles per gallon&quot; in that set, so usually that&#39;s what you&#39;d want on y. 00:43:38 Becki R. (she/her): Did I hear correctly that the dependent variable goes on the y-axis? 00:44:04 Jon Harmon (jonthegeek): Generally, yes. But it&#39;s whatever you specify as &quot;y&quot; in the &quot;aes&quot; call. 00:44:16 Becki R. (she/her): ok thanks 00:49:24 Jon Harmon (jonthegeek): The &quot;labs&quot; function is for all of the labels for your plot. 00:51:26 Jon Harmon (jonthegeek): https://twitter.com/search?q=%23tidytuesday&amp;src=typed_query 00:51:48 Hector: Is there any specific use for the ggtitle() function in contrast with labs() ? 00:52:09 Njoki Njuki Lucy: what is there a difference between stat=&quot;count&quot; and stat=&quot;identity&quot;? I understand stat = &quot;count returns count per each level. 00:53:23 Jon Harmon (jonthegeek): @Hector: ggtitle is equivalent to labs() for just the title and subtitle parts. It&#39;s just to make it easier to focus on those specific bits. 00:53:56 Jon Harmon (jonthegeek): @Njoki: &quot;count&quot; means &quot;how many entries have this value?&quot;, vs &quot;identity&quot; means &quot;what value is in this cell?&quot; 00:54:59 Hector: Thank you! 00:55:04 Njoki Njuki Lucy: thank you. 00:56:26 Jon Harmon (jonthegeek): &quot;color&quot; = outside, &quot;fill&quot; = inside 00:58:53 docksbox@pm.me: labs() 01:04:36 Ryan Metcalf: Could it be stated that ‚Äúlabs‚Äù is a more eloquent way of labeling than explicitly calling each field directly? Less lines of code maybe? 01:05:47 Jon Harmon (jonthegeek): I&#39;m not sure I&#39;d say &quot;eloquent,&quot; but it&#39;s just another option. They provide the separate functions in case you&#39;re looking for them, basically. 01:07:23 Jon Harmon (jonthegeek): Sorry about that! 01:08:23 Susie Neilson: This was a great presentation - thank you so much Federica! 01:12:31 docksbox@pm.me: example would be the use of a map data 01:12:51 Saeed Shafiei Sabet: Thanks Federica :) 01:13:43 docksbox@pm.me: great thanks! 01:13:46 Fodil: thank you everyone was very interesting. 01:13:51 Becki R. (she/her): Thanks, Federica! 01:13:56 Njoki Njuki Lucy: Thank you. 01:13:56 Saeed Shafiei Sabet: Thank you 01:13:58 Saeed Shafiei Sabet: bye "],["workflow-basics.html", "Chapter 4 Workflow: basics", " Chapter 4 Workflow: basics Learning objectives: Understand the RStudio interface Use the R command line boldly Follow good style conventions when writing code Confidently call functions in R "],["the-console-pane.html", "4.1 The Console Pane", " 4.1 The Console Pane "],["the-script-pane.html", "The Script Pane", " The Script Pane "],["the-environment-pane.html", "The Environment Pane", " The Environment Pane "],["the-other-pane.html", "The Other Pane", " The Other Pane "],["using-the-console.html", "Using the Console", " Using the Console Conceptually, everything we do in R is a series of commands. The console is where we can enter these commands. By default, entering &lt;thing&gt; means ‚Äúprint out &lt;thing&gt;.‚Äù 4 ## [1] 4 "],["using-the-console-1.html", "Using the Console", " Using the Console R has some pre-defined named objects: pi ## [1] 3.141593 This one is surprisingly useful: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; "],["using-the-console-2.html", "Using the Console", " Using the Console What it means to ‚Äúprint out‚Äù a thing depends on what kind of thing it is. ggplot2::diamonds ## # A tibble: 53,940 √ó 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # ‚Ä¶ with 53,930 more rows "],["using-the-console-3.html", "Using the Console", " Using the Console Actually, entering &lt;thing&gt; really means ‚Äúevaluate and print &lt;thing&gt;.‚Äù cos(pi) ## [1] -1 I use R as a desktop calculator a lot. 60*60*24 ## [1] 86400 "],["assigning-names.html", "Assigning Names", " Assigning Names Sometimes you don‚Äôt just want to print out a thing, especially if it‚Äôs a complex evaluation. You want to save it to a named object so that you can do more stuff with it. Use the assignment arrow (&lt;-) for this. tau &lt;- 2*pi Most programming languages use the equals sign (=) for assignment, and this also works in R. But assignment is really a conceptually distinct thing from mathematical equality, so it makes sense to use a different symbol. It‚Äôs a bit more annoying to type, though, so get used to the keyboard shortcut Alt+minus. Objects that you have named will show up in the ‚ÄúEnvironment‚Äù panel. "],["assigning-and-printing.html", "Assigning and Printing", " Assigning and Printing By default, when you make an assignment, the result of the evaluation is not printed in the console. To assign and print in one command, surround the assignment with parentheses: (tau &lt;- 2*pi) ## [1] 6.283185 "],["pronouncing-code.html", "Pronouncing Code", " Pronouncing Code It‚Äôs easier to remember and understand a thing if you can say it (either out loud or in your head). A common pronunciation of &lt;- is ‚Äúgets,‚Äù so tau &lt;- 2*pi would be read as ‚Äútau gets two times pi.‚Äù "],["naming-things.html", "4.2 Naming Things", " 4.2 Naming Things There are only two hard things in computer science: cache invalidation and naming things. And off-by-one errors. Picking good names for things is both harder and more important than you might guess. Having good guidelines for naming things can save you a lot of mental effort down the road. Names in R can only contain letters, numbers, _, and .. R is case-sensitive! And it can‚Äôt read your mind. Sticking with a good style convention will make your code more readable, both for others, and for yourself in the future. Some suggestions: Use descriptive names. Long names are ok! Use all lowercase by default, with _ as a separator. student_item_data num_students fall2020_math_courses_with_multiple_sections "],["functions.html", "4.3 Functions", " 4.3 Functions A function in R is like a function in math: it‚Äôs a box that takes in input and returns output.1 Functions can take zero, one, or more than one object as input. When you call a function, you specify values (arguments) for the inputs. Evaluating the function call gives the output of the function. length(letters) ## [1] 26 Or: nrow(ggplot2::diamonds) ## [1] 53940 Functions may also have side effects, which is something we can talk about later.‚Ü©Ô∏é "],["functions-1.html", "Functions", " Functions The inputs (the function parameters) have names. When you pass in the function arguments, you can do so by name: seq(from = 1, to = 10) ## [1] 1 2 3 4 5 6 7 8 9 10 Specifying names is (usually) optional, but it can make your code more readable, so it‚Äôs a good habit to get into. If you name the arguments, it doesn‚Äôt matter what order you put them in: seq(to = 10, from = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 If you don‚Äôt specify names, the function matches the arguments to the parameters in the order they appear in the function definition. seq(10, 1) ## [1] 10 9 8 7 6 5 4 3 2 1 "],["other-rstudio-features.html", "Other RStudio Features", " Other RStudio Features Explore on your own: tab autocomplete up-arrow to see console history type, then command- (control-) up-arrow to search history alt-shift-k to see lots of shortcuts one of my recent favorites: alt-command-down-arrow (inside a script) "],["meeting-videos-2.html", "4.4 Meeting Videos", " 4.4 Meeting Videos 4.4.1 Cohort 1 Meeting chat log 00:14:44 Jon Harmon (jonthegeek): Ignore the URL on these, I should have made my coworker crop those out since it isn&#39;t relevant outside of our work environment üôÉ 00:47:00 Jon Harmon (jonthegeek): ?variable.names 00:58:53 Becki R. (she/her): jon_doe is an object? 00:59:05 Wai-Yin: Yes. 01:10:33 Becki R. (she/her): Is there a list of verbal substitutions like &quot;&lt;- = get&quot;? 01:16:05 Jon Harmon (jonthegeek): Not yet! Some more will come up as we go through the book... and I plan on putting something together with them before too long! 01:16:56 Becki R. (she/her): Nice! 01:20:44 docksbox@pm.me: Thanks 01:22:41 Becki R. (she/her): Thanks everyone! I will not be here next week. "],["data-transformation.html", "Chapter 5 Data transformation", " Chapter 5 Data transformation Learning objectives: Pick out rows of a data frame with the dplyr::filter() function. Sort rows of a data frame with dplyr::arrange(). Pick out columns of a data frame with dplyr::select(). Modify columns of a data frame with dplyr::mutate(). Group rows of a data frame with dplyr::group(). Apply functions to columns of a (grouped) data frame with dplyr::summarize(). Streamline data transformations with the pipe operator (%&gt;%). "],["introduction-1.html", "5.1 Introduction", " 5.1 Introduction 5.1.1 Prerequisites dplyr is a package that provides functions to manipulate data frames. Data frame consists of columns (variables) and rows (observations). dplyr is part of the tidyverse. You can install and load the all the packages from tidyverse (ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats) install.packages(&quot;tidyverse&quot;) library(tidyverse) Or just install and load dplyr. install.packages(&quot;dplyr&quot;) library(dplyr) 5.1.2 nycflights13 The data set nycflights13 contains data about flights that departed New York City in 2013. install.packages(&quot;nycflights13&quot;) library(nycflights13) When you use data set for the first time, it‚Äôs good practice to quickly browse the data to check if you want to use the data. To view the flights data in the R console. . flights ## # A tibble: 336,776 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ‚Ä¶ with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; To view the flights data in a spreadsheet-like viewer. View(flights) Use ?flights to open the help viewer to get info about all the variables. ?flights Check the size of the flights data frame using nrow(), ncol(), length(), and dim(). # number of rows nrow(flights) # [1] 336776 # number of columns ncol(flights) # [1] 19 # number of columns length(flights) # [1] 19 # number of rows and columns dim(flights) # [1] 336776 19 get the column names with colnames() colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; "],["comparisons-and-logical-operators.html", "5.2 Comparisons and logical operators", " 5.2 Comparisons and logical operators 5.2.1 Comparisons &gt; greater than &gt;= greater than or equal &lt; less than &lt;= less than or equal == equal != not equal In math we use = for equality. In programming we use == for equality, and = for assignment. compare numbers 1 &gt; 2 # [1] FALSE 1 &gt;= 2 # [1] FALSE 1 &lt; 2 # [1] TRUE 1 &lt;= 2 # [1] TRUE 1 == 2 # [1] FALSE 1 != 2 # [1] TRUE compare characters &#39;a&#39; &gt; &#39;b&#39; # [1] FALSE &#39;a&#39; &gt;= &#39;b&#39; # [1] FALSE &#39;a&#39; &lt; &#39;b&#39; # [1] TRUE &#39;a&#39; &lt;= &#39;b&#39; # [1] TRUE &#39;a&#39; == &#39;b&#39; # [1] FALSE &#39;a&#39; != &#39;b&#39; # [1] TRUE Case matters when comparing characters. For English, lowercase letters are less than uppercase letters. &#39;a&#39; &gt; &#39;A&#39; # [1] FALSE &#39;a&#39; &gt;= &#39;A&#39; # [1] FALSE &#39;a&#39; &lt; &#39;A&#39; # [1] TRUE &#39;a&#39; &lt;= &#39;A&#39; # [1] TRUE &#39;a&#39; == &#39;A&#39; # [1] FALSE &#39;a&#39; != &#39;A&#39; # [1] TRUE We can change case when comparing characters. tolower() will change characters to lower case. toupper() will change characters to upper case. tolower(&#39;A&#39;) # [1] &quot;a&quot; toupper(&#39;a&#39;) # [1] &quot;A&quot; &#39;a&#39; == tolower(&#39;A&#39;) # [1] TRUE toupper(&#39;a&#39;) == &#39;A&#39; # [1] TRUE 5.2.2 Logical operators &amp; and; all expressions must be true in order to return true TRUE &amp; TRUE # [1] TRUE TRUE &amp; FALSE # [1] FALSE | or; one or more expressions must be true in order to return true; | is the key above the return key, not lowercase letter l. TRUE | TRUE # [1] TRUE TRUE | FALSE # [1] TRUE ! not; negate the expression !TRUE # [1] FALSE !FALSE # [1] TRUE !!TRUE # [1] TRUE assign objects a &lt;- 1 b &lt;- 5 compare object and numbers a &lt; 3 # [1] TRUE a &gt; 3 # [1] FALSE a == 3 # [1] FALSE a != 3 # [1] TRUE compare objects a &lt; b # [1] TRUE a &gt; b # [1] FALSE a == b # [1] FALSE a != b # [1] TRUE comparison and logical operators a &gt; 3 # [1] FALSE b &gt; 3 # [1] TRUE a &gt; 3 &amp; b &gt; 3 # [1] FALSE a &gt; 3 | b &gt; 3 # [1] TRUE !(a == b) # [1] TRUE "],["filter-rows-with-filter.html", "5.3 Filter rows with filter()", " 5.3 Filter rows with filter() filter() allows you to pick out certain rows (observations) . filter() picks the rows which evaluates to TRUE for all criteria. The first argument to filter() is a data frame, the subsequent arguments are the expressions. Combine comparisons and logical operators on the columns to select rows. # number of rows and columns dim(flights) ## [1] 336776 19 # get the column names colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; # select flights from November filter(flights, month == 11) ## # A tibble: 27,268 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # ‚Ä¶ with 27,258 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; A tibble: 27,268 √ó 19 tells you 27,268 rows match the criteria # select flights from December filter(flights, month == 12) ## # A tibble: 28,135 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 12 1 13 2359 14 446 445 ## 2 2013 12 1 17 2359 18 443 437 ## 3 2013 12 1 453 500 -7 636 651 ## 4 2013 12 1 520 515 5 749 808 ## 5 2013 12 1 536 540 -4 845 850 ## 6 2013 12 1 540 550 -10 1005 1027 ## 7 2013 12 1 541 545 -4 734 755 ## 8 2013 12 1 546 545 1 826 835 ## 9 2013 12 1 549 600 -11 648 659 ## 10 2013 12 1 550 600 -10 825 854 ## # ‚Ä¶ with 28,125 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # select flights not from December (e.g. January to November) filter(flights, month != 12) ## # A tibble: 308,641 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ‚Ä¶ with 308,631 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # select flights from November or December filter(flights, month == 11 | month == 12) ## # A tibble: 55,403 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # ‚Ä¶ with 55,393 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; &amp; (and) vs | (or) # select flights from November or from 1st day of any month filter(flights, month == 11 | day == 1) ## # A tibble: 37,318 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ‚Ä¶ with 37,308 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # select flights from November 1st filter(flights, month == 11 &amp; day == 1) ## # A tibble: 986 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # ‚Ä¶ with 976 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; If you provide multiple comma-separated expressions, dplyr will automatically use &amp; to combine the expressions. # both will select flights from November 1st filter(flights, month == 11 &amp; day == 1) filter(flights, month == 11, day == 1) dplyr functions do not change the original data. To save the results from a function, you need to assign the results to a object. nov1 &lt;- filter(flights, month == 11, day == 1) nrow(nov1) ## [1] 986 nrow(flights) ## [1] 336776 5.3.1 Missing values Often times, rows will not have data for certain columns. In spreadsheets, csv, tsv, the cells will be blank. In R data frames, the missing values are represented as NA (not available). Operations with NA will return NA. NA &gt; 5 # [1] NA 10 == NA # [1] NA NA + 10 # [1] NA NA / 2 # [1] NA NA == NA # [1] NA To check if value is missing use is.na() is.na(NA) # [1] TRUE By default, filter() excludes NA values. To include NA values, you must add an expression. tibble is the tidyverse version of a data frame. tibble haves some extra functions that normal data frames do not have. # create a tibble with a column named &quot;x&quot;, with 3 values df &lt;- tibble(x = c(1, NA, 3)) df ## # A tibble: 3 √ó 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 NA ## 3 3 # select rows with values greater than 1 filter(df, x &gt; 1) ## # A tibble: 1 √ó 1 ## x ## &lt;dbl&gt; ## 1 3 # select rows with NA or values greater than 1 filter(df, is.na(x) | x &gt; 1) ## # A tibble: 2 √ó 1 ## x ## &lt;dbl&gt; ## 1 NA ## 2 3 "],["arrange-rows-with-arrange.html", "5.4 Arrange rows with arrange()", " 5.4 Arrange rows with arrange() arrange() changes the order of the rows. The first argument to arrange() is a data frame, the subsequent arguments are columns names are expression used to sort the rows. Ascending (small to big) is the default order. Use desc() for descending order (big to small). # sort flights by depature delay using ascending order arrange(flights, dep_delay) ## # A tibble: 336,776 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 12 7 2040 2123 -43 40 2352 ## 2 2013 2 3 2022 2055 -33 2240 2338 ## 3 2013 11 10 1408 1440 -32 1549 1559 ## 4 2013 1 11 1900 1930 -30 2233 2243 ## 5 2013 1 29 1703 1730 -27 1947 1957 ## 6 2013 8 9 729 755 -26 1002 955 ## 7 2013 10 23 1907 1932 -25 2143 2143 ## 8 2013 3 30 2030 2055 -25 2213 2250 ## 9 2013 3 2 1431 1455 -24 1601 1631 ## 10 2013 5 5 934 958 -24 1225 1309 ## # ‚Ä¶ with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # sort flights by depature delay using descending order. arrange(flights, desc(dep_delay)) ## # A tibble: 336,776 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 1530 ## 2 2013 6 15 1432 1935 1137 1607 2120 ## 3 2013 1 10 1121 1635 1126 1239 1810 ## 4 2013 9 20 1139 1845 1014 1457 2210 ## 5 2013 7 22 845 1600 1005 1044 1815 ## 6 2013 4 10 1100 1900 960 1342 2211 ## 7 2013 3 17 2321 810 911 135 1020 ## 8 2013 6 27 959 1900 899 1236 2226 ## 9 2013 7 22 2257 759 898 121 1026 ## 10 2013 12 5 756 1700 896 1058 2020 ## # ‚Ä¶ with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; sort by multiple columns # sort flights by year, month, and day using ascending order arrange(flights, year, month, day) ## # A tibble: 336,776 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ‚Ä¶ with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange() puts NA values at the end. # create tibble with 3 values df &lt;- tibble(x = c(1, NA, 3)) # sort puts NA at the end arrange(df, x) ## # A tibble: 3 √ó 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 3 ## 3 NA "],["select-columns-with-select.html", "5.5 Select columns with select()", " 5.5 Select columns with select() select() lets you pick which columns (variables) to use. The first argument to select() is a data frame, the subsequent arguments are columns to use. # colnames() retrieves the column names colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; the order you list the columns will determine the order of the columns returned by select(). # select year, month, and day columns. select(flights, year, month, day) ## # A tibble: 336,776 √ó 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # ‚Ä¶ with 336,766 more rows # use &#39;:&#39; to select columns from year to day (inclusive). select(flights, year:day) ## # A tibble: 336,776 √ó 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # ‚Ä¶ with 336,766 more rows # use &#39;-&#39; to select columns except from year to day (inclusive). select(flights, -(year:day)) ## # A tibble: 336,776 √ó 16 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## 7 555 600 -5 913 854 19 B6 ## 8 557 600 -3 709 723 -14 EV ## 9 557 600 -3 838 846 -8 B6 ## 10 558 600 -2 753 745 8 AA ## # ‚Ä¶ with 336,766 more rows, and 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; helper functions for select() starts_with() # select columns that start with &quot;dep&quot; select(flights, starts_with(&quot;dep&quot;)) ## # A tibble: 336,776 √ó 2 ## dep_time dep_delay ## &lt;int&gt; &lt;dbl&gt; ## 1 517 2 ## 2 533 4 ## 3 542 2 ## 4 544 -1 ## 5 554 -6 ## 6 554 -4 ## 7 555 -5 ## 8 557 -3 ## 9 557 -3 ## 10 558 -2 ## # ‚Ä¶ with 336,766 more rows ends_with() # select columns that end with &quot;delay&quot; select(flights, ends_with(&quot;delay&quot;)) ## # A tibble: 336,776 √ó 2 ## dep_delay arr_delay ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 ## 2 4 20 ## 3 2 33 ## 4 -1 -18 ## 5 -6 -25 ## 6 -4 12 ## 7 -5 19 ## 8 -3 -14 ## 9 -3 -8 ## 10 -2 8 ## # ‚Ä¶ with 336,766 more rows contains() # select columns that contain &quot;dep&quot; select(flights, contains(&quot;dep&quot;)) ## # A tibble: 336,776 √ó 3 ## dep_time sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 2 ## 2 533 529 4 ## 3 542 540 2 ## 4 544 545 -1 ## 5 554 600 -6 ## 6 554 558 -4 ## 7 555 600 -5 ## 8 557 600 -3 ## 9 557 600 -3 ## 10 558 600 -2 ## # ‚Ä¶ with 336,766 more rows matches() # select columns that matches regular expression. # &quot;^a(.)r&quot; means it starts with a, has any character, and then r. select(flights, matches(&quot;^a(.)r&quot;)) ## # A tibble: 336,776 √ó 3 ## arr_time arr_delay air_time ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 830 11 227 ## 2 850 20 227 ## 3 923 33 160 ## 4 1004 -18 183 ## 5 812 -25 116 ## 6 740 12 150 ## 7 913 19 158 ## 8 709 -14 53 ## 9 838 -8 140 ## 10 753 8 138 ## # ‚Ä¶ with 336,766 more rows num_range() # create tibble with columns x1, x2, x3, x4 df &lt;- tibble(x1 = c(1, 2), x2 = c(2, 3), x3 = c(4, 5), x4 = c(6, 7)) # select column that matches x1, x2 and x3 select(df, num_range(&quot;x&quot;, 1:3)) ## # A tibble: 2 √ó 3 ## x1 x2 x3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 4 ## 2 2 3 5 rename() changes the column names. rename(data_frame, new_name = old_name) # rename the column dep_time to departure_time rename(flights, departure_time = dep_time) ## # A tibble: 336,776 √ó 19 ## year month day departure_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ‚Ä¶ with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; use select() and everything() to move some columns to start of the dataframe # rearrange columns to time_hour, air_time, rest of the columns select(flights, time_hour, air_time, everything()) ## # A tibble: 336,776 √ó 19 ## time_hour air_time year month day dep_time sched_dep_time ## &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 05:00:00 227 2013 1 1 517 515 ## 2 2013-01-01 05:00:00 227 2013 1 1 533 529 ## 3 2013-01-01 05:00:00 160 2013 1 1 542 540 ## 4 2013-01-01 05:00:00 183 2013 1 1 544 545 ## 5 2013-01-01 06:00:00 116 2013 1 1 554 600 ## 6 2013-01-01 05:00:00 150 2013 1 1 554 558 ## 7 2013-01-01 06:00:00 158 2013 1 1 555 600 ## 8 2013-01-01 06:00:00 53 2013 1 1 557 600 ## 9 2013-01-01 06:00:00 140 2013 1 1 557 600 ## 10 2013-01-01 06:00:00 138 2013 1 1 558 600 ## # ‚Ä¶ with 336,766 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, ## # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt; "],["add-new-variables-with-mutate.html", "5.6 Add new variables with mutate()", " 5.6 Add new variables with mutate() mutate() adds new columns based on values from existing columns. Data frame includes existing and new columns. # create data frame with 7 columns: year, month, day, dep_delay, arr_delay, distance, air_time flights_7_columns &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) # calculate and add columns for gain, hours, and gain_per_hour mutate(flights_7_columns, gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 √ó 10 ## year month day dep_delay arr_delay distance air_time gain hours ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 -9 3.78 ## 2 2013 1 1 4 20 1416 227 -16 3.78 ## 3 2013 1 1 2 33 1089 160 -31 2.67 ## 4 2013 1 1 -1 -18 1576 183 17 3.05 ## 5 2013 1 1 -6 -25 762 116 19 1.93 ## 6 2013 1 1 -4 12 719 150 -16 2.5 ## 7 2013 1 1 -5 19 1065 158 -24 2.63 ## 8 2013 1 1 -3 -14 229 53 11 0.883 ## 9 2013 1 1 -3 -8 944 140 5 2.33 ## 10 2013 1 1 -2 8 733 138 -10 2.3 ## # ‚Ä¶ with 336,766 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt; transmute() adds new columns based on values from existing columns. Data frame only includes new columns. # calculate and add columns for gain, hours, and gain_per_hour transmute(flights_7_columns, gain = dep_delay - arr_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 √ó 3 ## gain hours gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -9 3.78 -2.38 ## 2 -16 3.78 -4.23 ## 3 -31 2.67 -11.6 ## 4 17 3.05 5.57 ## 5 19 1.93 9.83 ## 6 -16 2.5 -6.4 ## 7 -24 2.63 -9.11 ## 8 11 0.883 12.5 ## 9 5 2.33 2.14 ## 10 -10 2.3 -4.35 ## # ‚Ä¶ with 336,766 more rows 5.6.1 Useful creation functions There are many functions to use with mutate(). The function must be vectorised: it must take a vector of values as input, return a vector with the same number of values as output. Arithmetic operators: +, -, *, /, ^ aggregate functions: sum, mean Modular arithmetic: %/% (integer division) and %% (remainder) Logs: log(), log2(), log10() Offsets: lead() leading values; lag() lagging values. Cumulative and rolling aggregates: cumsum() cumulative sums, cumprod() cumulative products, cummin() cumulative min, cummax() cumulative max, cummean() cumulative means. Logical comparisons: &lt;, &lt;=, &gt;, &gt;=, !=, and == Ranking: min_rank(x) gives ranks from smallest to largest. min_rank(desc(x)) gives ranks from largest to smallest. row_number(), dense_rank(), percent_rank(), cume_dist(), ntile(). Testing out various functions to see what they do. transmute(flights, dep_time, arr_time, # Modular arithmetic dep_hour = dep_time %/% 100, dep_minute = dep_time %% 100, # Arithmetic duration = arr_time - dep_time, # logs log_duration = log2(duration), # Offsets lead_duration = lead(duration) ) ## Warning in mask$eval_all_mutate(quo): NaNs produced ## # A tibble: 336,776 √ó 7 ## dep_time arr_time dep_hour dep_minute duration log_duration lead_duration ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 517 830 5 17 313 8.29 317 ## 2 533 850 5 33 317 8.31 381 ## 3 542 923 5 42 381 8.57 460 ## 4 544 1004 5 44 460 8.85 258 ## 5 554 812 5 54 258 8.01 186 ## 6 554 740 5 54 186 7.54 358 ## 7 555 913 5 55 358 8.48 152 ## 8 557 709 5 57 152 7.25 281 ## 9 557 838 5 57 281 8.13 195 ## 10 558 753 5 58 195 7.61 291 ## # ‚Ä¶ with 336,766 more rows transmute(flights, dep_time, arr_time, # Arithmetic duration = arr_time - dep_time, # Cumulative aggregates cumsum_duration = cumsum(duration), # Logical comparisons long_duration = duration &gt; 300, # Ranking rank_duration = min_rank(duration) ) ## # A tibble: 336,776 √ó 6 ## dep_time arr_time duration cumsum_duration long_duration rank_duration ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; &lt;int&gt; ## 1 517 830 313 313 TRUE 285919 ## 2 533 850 317 630 TRUE 290078 ## 3 542 923 381 1011 TRUE 317071 ## 4 544 1004 460 1471 TRUE 325198 ## 5 554 812 258 1729 FALSE 199982 ## 6 554 740 186 1915 FALSE 114148 ## 7 555 913 358 2273 TRUE 307731 ## 8 557 709 152 2425 FALSE 77988 ## 9 557 838 281 2706 FALSE 224583 ## 10 558 753 195 2901 FALSE 129730 ## # ‚Ä¶ with 336,766 more rows "],["grouped-summaries-with-summarize.html", "5.7 Grouped summaries with summarize()", " 5.7 Grouped summaries with summarize() summarize() or summarise() collapses a data frame to a single row By default, summarize includes NA values. summarize() will return NA if any values are NA. # calculate the mean departure delay for all the flights. Include NA. summarize(flights, delay = mean(dep_delay)) ## # A tibble: 1 √ó 1 ## delay ## &lt;dbl&gt; ## 1 NA Need to use na.rm = TRUE to remove NA values. # calculate the mean departure delay for all the flights. Remove NA. summarize(flights, delay = mean(dep_delay, na.rm = TRUE)) ## # A tibble: 1 √ó 1 ## delay ## &lt;dbl&gt; ## 1 12.6 You use nrow(), filter(), and is.na() check the number of NA values for a column. # total rows in flights nrow(flights) ## [1] 336776 # [1] 336776 # rows where dep_delay is NA nrow(filter(flights, is.na(dep_delay))) ## [1] 8255 # [1] 8255 # rows where dep_delay has a value nrow(filter(flights, !is.na(dep_delay))) ## [1] 328521 # [1] 328521 Use summarize() and group_by() to calculate values for each group. # group flights by year, month and day to get daily flights by_day &lt;- group_by(flights, year, month, day) # calculate mean departure delay for each day summarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 √ó 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # ‚Ä¶ with 355 more rows 5.7.1 Combining multiple operations with the pipe Use pipe %&gt;% to perform multiple operations on a data set. Do step 1, and then do step 2‚Ä¶ pipe makes code more readable. # groyup flights by day, and then calculate mean departure delay for each day flights %&gt;% group_by(year, month, day) %&gt;% summarize(delay = mean(dep_delay, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 √ó 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # ‚Ä¶ with 355 more rows 5.7.2 Counts Whenever you do any aggregation, you should include a count of values n(), or a count of non-missing values sum(!is.na(x)) to check number of items per group. # get flights that were not cancelled not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) # group flights by tail number, and then calculate mean arrival delay and number of not canceled flights for each tail number delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarize( delay = mean(arr_delay, na.rm = TRUE), n = n() ) delays ## # A tibble: 4,037 √ó 3 ## tailnum delay n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 D942DN 31.5 4 ## 2 N0EGMQ 9.98 352 ## 3 N10156 12.7 145 ## 4 N102UW 2.94 48 ## 5 N103US -6.93 46 ## 6 N104UW 1.80 46 ## 7 N10575 20.7 269 ## 8 N105UW -0.267 45 ## 9 N107US -5.73 41 ## 10 N108UW -1.25 60 ## # ‚Ä¶ with 4,027 more rows combine dplyr with ggplot to rearrange and plot data. dplyr and rest of tidyverse uses %\\&gt;%; ggplot uses + # pick the delayed flights with more than 25 flights, and then plot the flights. delays %&gt;% filter(n &gt; 25) %&gt;% ggplot(mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) 5.7.3 Useful summary functions Many functions can be used with summarize() Measures of location: median(x) value where 50% of x is above it, and 50% is below it. Measures of spread: sd(x) standard deviation is the standard measure of spread. interquartile range IQR(x) and median absolute deviation mad(x) are good if there are outliers. Measures of rank: min(x), quantile(x, 0.25), max(x) Measures of position: first(x), nth(x, 2), last(x). Counts: n() returns the size of the current group. sum(!is.na(x)) returns the number of non-missing values. n_distinct(x) returns the number of unique values. count() is a shortcut for group_by() and summarize() to return count by group. # count the number of flights per destination not_cancelled %&gt;% group_by(dest) %&gt;% summarize(n = n()) ## # A tibble: 104 √ó 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ABQ 254 ## 2 ACK 264 ## 3 ALB 418 ## 4 ANC 8 ## 5 ATL 16837 ## 6 AUS 2411 ## 7 AVL 261 ## 8 BDL 412 ## 9 BGR 358 ## 10 BHM 269 ## # ‚Ä¶ with 94 more rows # count the number of flights per destination not_cancelled %&gt;% count(dest) ## # A tibble: 104 √ó 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ABQ 254 ## 2 ACK 264 ## 3 ALB 418 ## 4 ANC 8 ## 5 ATL 16837 ## 6 AUS 2411 ## 7 AVL 261 ## 8 BDL 412 ## 9 BGR 358 ## 10 BHM 269 ## # ‚Ä¶ with 94 more rows use sort=TRUE with count() to sort the counts # count the number of flights per destination, and sort the results not_cancelled %&gt;% count(dest, sort=TRUE) ## # A tibble: 104 √ó 2 ## dest n ## &lt;chr&gt; &lt;int&gt; ## 1 ATL 16837 ## 2 ORD 16566 ## 3 LAX 16026 ## 4 BOS 15022 ## 5 MCO 13967 ## 6 CLT 13674 ## 7 SFO 13173 ## 8 FLL 11897 ## 9 MIA 11593 ## 10 DCA 9111 ## # ‚Ä¶ with 94 more rows optionally provide a weight variable to get a sum of that variable. # get the total number of miles planes flew for each destination not_cancelled %&gt;% count(dest, wt = distance) ## # A tibble: 104 √ó 2 ## dest n ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ 463804 ## 2 ACK 52536 ## 3 ALB 59774 ## 4 ANC 26960 ## 5 ATL 12747938 ## 6 AUS 3650862 ## 7 AVL 152323 ## 8 BDL 47792 ## 9 BGR 135324 ## 10 BHM 232953 ## # ‚Ä¶ with 94 more rows When used with numeric functions, TRUE is converted to 1 and FALSE is converted to 0. sum(TRUE) # [1] 1 sum(5 &gt; 0) # [1] 1 sum(FALSE) # [1] 0 sum(5 &lt; 0) # [1] 0 Counts and proportions of logical values: sum(x) gives the number of TRUEs, and mean(x) gives the proportion of TRUEs. # number of flight per day delayed by more than an 60 minutes not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(hour_count = sum(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 √ó 4 ## # Groups: year, month [12] ## year month day hour_count ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 60 ## 2 2013 1 2 79 ## 3 2013 1 3 51 ## 4 2013 1 4 36 ## 5 2013 1 5 25 ## 6 2013 1 6 39 ## 7 2013 1 7 31 ## 8 2013 1 8 19 ## 9 2013 1 9 18 ## 10 2013 1 10 17 ## # ‚Ä¶ with 355 more rows # proportion of flights per day delayed by more than an 60 minutes not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(hour_prop = mean(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 √ó 4 ## # Groups: year, month [12] ## year month day hour_prop ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 0.0722 ## 2 2013 1 2 0.0851 ## 3 2013 1 3 0.0567 ## 4 2013 1 4 0.0396 ## 5 2013 1 5 0.0349 ## 6 2013 1 6 0.0470 ## 7 2013 1 7 0.0333 ## 8 2013 1 8 0.0213 ## 9 2013 1 9 0.0202 ## 10 2013 1 10 0.0183 ## # ‚Ä¶ with 355 more rows 5.7.4 Grouping by multiple variables progressively rolling up summaries for sums and counts # group flights by day daily &lt;- group_by(flights, year, month, day) # number flights per day (per_day &lt;- summarize(daily, flights = n())) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 √ó 4 ## # Groups: year, month [12] ## year month day flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 842 ## 2 2013 1 2 943 ## 3 2013 1 3 914 ## 4 2013 1 4 915 ## 5 2013 1 5 720 ## 6 2013 1 6 832 ## 7 2013 1 7 933 ## 8 2013 1 8 899 ## 9 2013 1 9 902 ## 10 2013 1 10 932 ## # ‚Ä¶ with 355 more rows # number flights per month (per_month &lt;- summarize(per_day, flights = sum(flights))) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the `.groups` argument. ## # A tibble: 12 √ó 3 ## # Groups: year [1] ## year month flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 27004 ## 2 2013 2 24951 ## 3 2013 3 28834 ## 4 2013 4 28330 ## 5 2013 5 28796 ## 6 2013 6 28243 ## 7 2013 7 29425 ## 8 2013 8 29327 ## 9 2013 9 27574 ## 10 2013 10 28889 ## 11 2013 11 27268 ## 12 2013 12 28135 # number of flights per year (per_year &lt;- summarize(per_month, flights = sum(flights))) ## # A tibble: 1 √ó 2 ## year flights ## &lt;int&gt; &lt;int&gt; ## 1 2013 336776 5.7.5 Ungrouping ungroup() removes grouping. # ungroup the daily flights to count the total number of flights daily %&gt;% ungroup() %&gt;% summarize(flights = n()) ## # A tibble: 1 √ó 1 ## flights ## &lt;int&gt; ## 1 336776 If during analysis the data doesn‚Äôt look right, you can try to use ungroup() to check if the data was previously grouped. "],["grouped-mutates-and-filters.html", "5.8 Grouped mutates (and filters)", " 5.8 Grouped mutates (and filters) use group() with mutate() and filter() # get the flights with the top 10 largest arrival delays per day top_delay &lt;- flights_7_columns %&gt;% group_by(year, month, day) %&gt;% filter(rank(desc(arr_delay)) &lt;= 10) top_delay ## # A tibble: 3,609 √ó 7 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 ## 2 2013 1 1 290 338 1134 213 ## 3 2013 1 1 260 263 266 46 ## 4 2013 1 1 155 166 277 68 ## 5 2013 1 1 157 174 213 60 ## 6 2013 1 1 216 222 708 121 ## 7 2013 1 1 255 250 589 115 ## 8 2013 1 1 285 246 1085 146 ## 9 2013 1 1 192 191 199 44 ## 10 2013 1 1 379 456 1092 222 ## # ‚Ä¶ with 3,599 more rows # add rank column, and sort the rows by day and rank to check if top_delay # is returning what we expect top_delay %&gt;% mutate(rank = rank(desc(arr_delay)) ) %&gt;% arrange(year, month, day, rank) ## # A tibble: 3,609 √ó 8 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time rank ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 1 ## 2 2013 1 1 379 456 1092 222 2 ## 3 2013 1 1 290 338 1134 213 3 ## 4 2013 1 1 260 263 266 46 4 ## 5 2013 1 1 255 250 589 115 5 ## 6 2013 1 1 285 246 1085 146 6 ## 7 2013 1 1 216 222 708 121 7 ## 8 2013 1 1 192 191 199 44 8 ## 9 2013 1 1 157 174 213 60 9 ## 10 2013 1 1 155 166 277 68 10 ## # ‚Ä¶ with 3,599 more rows "],["meeting-videos-3.html", "5.9 Meeting Videos", " 5.9 Meeting Videos 5.9.1 Cohort 1 Meeting chat log 00:13:48 Jon Harmon (jonthegeek): &quot;dplyr&quot; as in &quot;data plyer&quot; (tools for working with data) 00:22:03 Ryan Metcalf: I call the | as ‚Äúhandlebar‚Äù‚Ä¶may be my own lingo too. 00:22:20 lucus w: I like vbar 00:38:30 Ryan Metcalf: Quick thought, on dat ingestion, does the tidyverse convert null to NA? Or an alternative, does is.na look for null too? 00:39:19 Jon Harmon (jonthegeek): Null coming in from a database will convert to NA. NULL specifically means &quot;does not exist,&quot; and can&#39;t be inside a vector of numbers in R. It&#39;s its own data type in R. 00:39:24 lucus w: I believe NA and NULL aren‚Äôt the same thing, so I‚Äôd guess no 00:39:53 Njoki Njuki Lucy: can one use filter to remove na? 00:40:01 Ryan Metcalf: üëçüèª 00:40:45 lucus w: filter(!is.na(x)) wil do the trick 00:40:51 Jon Harmon (jonthegeek): filter(flights, !is.na(month)) would remove NA rows. 00:41:05 Jon Harmon (jonthegeek): Lucus beat me to it :D 00:42:22 Njoki Njuki Lucy: awesome, thank you both :) 00:46:06 Jon Harmon (jonthegeek): Chapter 14 has more on regular expressions. 00:47:03 Jon Harmon (jonthegeek): https://regexr.com/ 00:58:04 lucus w: I wish all aggregate functions would have na.rm = TRUE as a default 01:04:21 lucus w: is magrittr a function or just an operator 01:04:35 lucus w: %&gt;% 01:04:38 Jon Harmon (jonthegeek): If you&#39;re curious why the pipe package is called magrittr: https://en.wikipedia.org/wiki/The_Treachery_of_Images#/media/File:MagrittePipe.jpg 01:05:02 Jon Harmon (jonthegeek): magrittr is the package which exports the %&gt;% function (but it&#39;s a special kind of function because it can go in the middle of its arguments) 01:16:15 Eileen: Great presentation 01:16:17 Ryan Metcalf: Great job! 01:16:34 LG: Thank you! 01:16:46 Njoki Njuki Lucy: Thank you! 01:17:40 Eileen: Thank you! "],["workflow-scripts.html", "Chapter 6 Workflow: scripts", " Chapter 6 Workflow: scripts Learning objectives: Use keyboard shortcuts to use the RStudio script pane efficiently. Understand the script diagnostics that the RStudio script editor provides. "],["meeting-videos-4.html", "6.1 Meeting Videos", " 6.1 Meeting Videos 6.1.1 Cohort 1 Meeting chat log 00:40:51 Becki R. (she/her): It works both ways, I think. It&#39;s just convention to use &lt;-. 00:45:11 Wai-Yin: You can use &lt;- or = for assignment. &lt;- is the convention in R. -&gt; results in ab error. 00:58:59 lucus w: https://www.rocker-project.org/ 01:01:43 Bruno A. Machado: tks Lucus for the link üëç 01:13:48 Susie N.: I have to head out! Thank you Ryan for the great breakdown 01:14:07 Federica Gazzelloni: Thanks! 01:14:19 Becki R. (she/her): Thanks everyone, see you next week! 01:17:04 Bruno A. Machado: tks team 01:17:21 Eileen Murphy: Thank you Ryan "],["exploratory-data-analysis.html", "Chapter 7 Exploratory Data Analysis ", " Chapter 7 Exploratory Data Analysis "],["learning-objectives.html", "7.1 Learning objectives", " 7.1 Learning objectives Recognize the two types of questions that will always be useful for making discoveries within your data: ‚ÄúWhat type of variation occurs within my variables?‚Äù and ‚ÄúWhat type of covariation occurs between my variables?‚Äù Explore the variation within the variables of your observations. Deal with outliers and missing values in your data. Explore the covariation between the variables of your observations. Recognize how models can be used to explore patterns in your data. "],["overall-vocabulary.html", "7.2 Overall Vocabulary", " 7.2 Overall Vocabulary variable: a quantity, quality, or property that you can measure. value: the state of a variable when you measure it. Can change. observation: a set of measurements made under similar conditions. One value per variable. tabular data: observations of variables. tidy data: 1 observation per row, 1 variable per column, 1 value per cell. Definition of ‚Äútidy‚Äù for a dataset can depend on what you‚Äôre trying to answer. "],["variation.html", "7.3 Variation", " 7.3 Variation variation: the tendency of values of a variable to change between measurements. categorical variable: can only take certain values. Visualize variation with bar chart. ggplot(data = diamonds) + aes(x = cut) + geom_bar() continuous variables: can take on infinite set of ordered values. Visualize variation with histogram. ggplot(data = diamonds) + aes(x = carat) + geom_histogram(binwidth = 0.5) geom_freqpoly is geom_histogram alternative that doesn‚Äôt show bars. Reminder: the %&gt;% pipe = ‚Äúand then‚Äù. {ggplot2} uses + to add layers, read it as ‚Äúwith‚Äù or ‚Äúand‚Äù. smaller &lt;- diamonds %&gt;% filter(carat &lt; 3) ggplot(smaller) + aes(x = carat, colour = cut) + geom_freqpoly(binwidth = 0.1) Use the visualizations to develop questions! Which values are the most common? Why? Which values are rare? Why? Does that match your expectations? Can you see any unusual patterns? What might explain them? ggplot(smaller, mapping = aes(x = carat)) + geom_histogram(binwidth = 0.01) Subgroups create more questions: How are the observations within each cluster similar to each other? How are the observations in separate clusters different from each other? How can you explain or describe the clusters? Why might the appearance of clusters be misleading? Use coord_cartesian to zoom in to see unusual values. Can be ok to drop weird values, especially if you can explain where they came from. Always disclose that you did that, though. "],["missing-values-1.html", "7.4 Missing values", " 7.4 Missing values 2 options to deal with weird values: Drop the entire row. &lt;‚Äì probably don‚Äôt do this Replace bad data with NA. diamonds2 &lt;- diamonds %&gt;% mutate(y = ifelse(y &lt; 3 | y &gt; 20, NA, y)) {ggplot2} will give a warning when values are missing, can suppress with na.rm = TRUE. "],["covariation.html", "7.5 Covariation", " 7.5 Covariation covariation: tendency of values of different variables to vary together in a related way. Visualizing covariance depends on types of variables in the pair: 7.5.1 categorical + continuous x = categorical y = continuous. geom_boxplot Lots of options exist to do this better. See Cedric Scherer‚Äôs tutorial! 7.5.2 categorical + categorical geom_count dplyr::count then geom_tile 7.5.3 continuous + continuous geom_point geom_bin2d geom_hex "],["finding-patterns.html", "7.6 Finding Patterns", " 7.6 Finding Patterns Ask yourself: Could this pattern be due to coincidence (i.e.¬†random chance)? How can you describe the relationship implied by the pattern? How strong is the relationship implied by the pattern? What other variables might affect the relationship? Does the relationship change if you look at individual subgroups of the data? "],["simplified-ggplot2.html", "7.7 Simplified ggplot2", " 7.7 Simplified ggplot2 ggplot(data = faithful, mapping = aes(x = eruptions)) + geom_freqpoly(binwidth = 0.25) ggplot(faithful, aes(eruptions)) + geom_freqpoly(binwidth = 0.25) # Or Jon&#39;s crazy way ggplot(faithful) + aes(eruptions) + geom_freqpoly(binwidth = 0.25) "],["learning-more.html", "7.8 Learning More", " 7.8 Learning More r4ds.io/join for more book clubs! R Graph Gallery The Graphs section of the R Cookbook "],["meeting-videos-5.html", "7.9 Meeting Videos", " 7.9 Meeting Videos 7.9.1 Cohort 1 Meeting chat log 00:13:43 Njoki Njuki Lucy: Is it best to visualize the variation in a categorical variable with only two levels using a bar chart? If not, what&#39;s the chart to use if I may ask? 00:16:00 Ryan Metcalf: Great question Njoki, Categorical, by definition is a set that a variable can have. Say, Male / Female / Other. This example indicates a variable can have three states. It depends on your data set. 00:16:51 Eileen: bar or pie chart? 00:16:51 Ryan Metcalf: There are other forms of presentation other than a bar chart. I.E ‚Äúquantifying‚Äù each category. 00:18:37 Eileen: box chart 00:18:46 Njoki Njuki Lucy: thank you so much everyone :) 00:24:31 lucus w: This website is excellent in determining geom to use: www.data-to-viz.com 00:25:22 Njoki Njuki Lucy: awesome, thanks 00:25:44 Eileen: Box charts are great for showing outliers 00:26:31 Federica Gazzelloni: other interesting resources: 00:26:34 Federica Gazzelloni: https://www.r-graph-gallery.com/ggplot2-package.html 00:26:51 Federica Gazzelloni: http://www.cookbook-r.com/Graphs/ 00:34:19 Amitrajit: what is the difference in putting aes() inside geom_count() rather than main ggplot() call? 00:35:38 Ryan Metcalf: Like maybe Supply vs Demand curves? 00:41:16 Federica Gazzelloni: what about the factor() that we add to a variable when we apply a color? 00:42:33 Susie Neilson: I do aes your way Jon! 00:43:07 Federica Gazzelloni: and grouping inside the aes 00:49:27 Amitrajit: thanks! 00:49:32 Federica Gazzelloni: thanks 00:49:35 Njoki Njuki Lucy: thank you, bye 00:49:45 Eileen: Thank you! "],["workflow-projects.html", "Chapter 8 Workflow: projects", " Chapter 8 Workflow: projects Learning objectives: Understand how to use Rstudio and the getwd() function to find your working directory. Recognize the similarities and differences between Windows paths and Mac/Linux paths. Create an Rstudio project. "],["meeting-videos-6.html", "8.1 Meeting Videos", " 8.1 Meeting Videos 8.1.1 Cohort 1 Meeting chat log 00:05:55 docksbox@pm.me: Hello! 00:07:40 Becki R. (she/her): Hello! 00:07:52 Sandra Muroy: Hi! 00:07:57 Federica Gazzelloni: Hi! 00:09:49 Eileen: Hello! 00:15:44 Becki R. (she/her): Very cool! 00:29:31 Jon Harmon (jonthegeek): https://CRAN.R-project.org/package=renv 00:31:35 lucus w: Or just here::here() package, it‚Äôs my favorite 00:32:48 Ryan Metcalf: Ah, Thank you Lucas! I think you may have solved an error I was trying to overcome! 00:32:57 Jon Harmon (jonthegeek): here::here(&quot;my_dir&quot;, &quot;myfile.R&quot;) 00:33:06 lucus w: There you go, yup 00:34:37 Jon Harmon (jonthegeek): usethis 00:34:38 lucus w: You can use usethis 00:37:56 Jon Harmon (jonthegeek): .Last.value 00:38:58 lucus w: It‚Äôs a life saver especially working in databases 00:44:32 Federica Gazzelloni: reticulate 00:45:11 Federica Gazzelloni: https://rstudio.github.io/reticulate/articles/r_markdown.html 00:48:18 Ryan Metcalf: @Shamsuddeen, what was that command again? Cmd + Shift + P? 00:48:40 Susan Neilson: That‚Äôs right 00:49:43 Ryan Metcalf: Awesome! Ive never used that before. These bookclub meetups are so helpful! Thank you everyone! 00:50:04 Federica Gazzelloni: yep! very useful 00:50:09 Shamsuddeen Muhammad: https://speakerdeck.com/jennybc/how-to-name-files 00:50:28 Shamsuddeen Muhammad: Naming things 00:51:10 Jon Harmon (jonthegeek): 20210904 00:51:55 Shamsuddeen Muhammad: Chapter 2 Project-oriented workflow : https://rstats.wtf/project-oriented-workflow.html 00:52:13 Jon Harmon (jonthegeek): Had to google that tab: https://bookdown.org/ndphillips/YaRrr/ 00:52:15 Shamsuddeen Muhammad: What They Forgot to Teach You About R 00:55:05 Jon Harmon (jonthegeek): https://github.com/MonkmanMH/EIKIFJB 00:55:38 Ryan Metcalf: Transmute I think‚Ä¶.. 00:56:27 Jon Harmon (jonthegeek): tidyr::replace_na() 00:56:54 lucus w: Check out janitor 01:02:32 Shamsuddeen Muhammad: https://tidyr.tidyverse.org/reference/replace_na.html 01:02:42 Shamsuddeen Muhammad: df %&gt;% dplyr::mutate(x = replace_na(x, 0)) 01:03:30 Jon Harmon (jonthegeek): &quot;&quot; 01:04:16 Ryan Metcalf: You‚Äôve discovered the beauty of a programmer!!! 01:04:28 Shamsuddeen Muhammad: Yes Yes !!! 01:05:22 Susan Neilson: ‚Äú95% of being a programmer is knowing how to Google‚Äù - my programmer friend 01:06:27 Ryan Metcalf: I find googling the package and then reading the PDF Manual. CRAN is your friend. 01:10:38 Sandra Muroy: thanks everyone for your input! 01:10:57 Ryan Metcalf: Thank you Susie! Great presentation and conversation! 01:11:04 Susan Neilson: Thanks everyone ! 01:11:08 Federica Gazzelloni: thanks 01:11:12 Becki R. (she/her): Thank you! 01:11:22 Susan Neilson: https://bookdown.org/ndphillips/YaRrr/rdata-files.html "],["introduction-2.html", "Chapter 9 Introduction", " Chapter 9 Introduction Learning objectives: Understand how data wrangling fits into the typical data science project. "],["slide-1.html", "9.1 Slide 1", " 9.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2.html", "9.2 Slide 2", " 9.2 Slide 2 Slide contents. "],["tibbles.html", "Chapter 10 Tibbles", " Chapter 10 Tibbles Learning objectives: Create tibbles in various ways. Compare and contrast tibbles with base R data.frames. Convert a tibble back to a data.frame, when needed. "],["slide-1-1.html", "10.1 Slide 1", " 10.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-1.html", "10.2 Slide 2", " 10.2 Slide 2 Slide contents. "],["data-import.html", "Chapter 11 Data import", " Chapter 11 Data import Learning objectives: Read data from disk using the readr::read_*() family of functions. Compare and contrast the read_*() functions with the base R equivalents. Parse character data into other data types using the readr::parse_*() functions. List the complications that can arise when parsing numerical strings. Understand how the various character encodings can make it tricky to parse characters. Describe the common conventions used for date/time data. Diagnose problems that may arise when using the read_*() functions. Write data to disk using the readr::write_*() family of functions. "],["slide-1-2.html", "11.1 Slide 1", " 11.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-2.html", "11.2 Slide 2", " 11.2 Slide 2 Slide contents. "],["tidy-data.html", "Chapter 12 Tidy data", " Chapter 12 Tidy data Learning objectives: Classify datasets as tidy or non-tidy. Pivot data to make it tidy. Separate and unite columns to make them tidy. Deal with missing values in a dataset. Combine functions to tidy a dataset. Recognize reasons that non-tidy data might be preferred in some cases. "],["slide-1-3.html", "12.1 Slide 1", " 12.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-3.html", "12.2 Slide 2", " 12.2 Slide 2 Slide contents. "],["relational-data.html", "Chapter 13 Relational data", " Chapter 13 Relational data Learning objectives: Recognize the families of verbs for working with relational data. Use keys (primary, foreign, and surrogate) to identify relations between tables. Use mutating joins to combine related tables. Use filtering joins to remove observations from a table. Recognize common problems with joins. Use set operations to combine or filter tables. "],["introduction-3.html", "13.1 Introduction", " 13.1 Introduction Multiple tables of data are called relational data. The basic idea is that relations are defined between a pair of tables. Multiple tables are put in relation starting from this basic idea. There are three families of verbs designed to work with relational data: Mutating joins, which add new variables to one data frame from matching observations in another. Filtering joins, which filter observations from one data frame based on whether or not they match an observation in the other table. Set operations, which treat observations as if they were set elements. "],["nycflights13-1.html", "13.2 nycflights13", " 13.2 nycflights13 How to make a custom table with different data sets nycflights13::airlines nycflights13::airports nycflights13::flights nycflights13::planes nycflights13::weather Relations: flights connects to planes via a single variable, tailnum. flights connects to airlines through the carrier variable. flights connects to airports in two ways: via the origin and dest variables. flights connects to weather via origin (the location), and year, month, day and hour (the time). Figure 13.1: nycfilghts13 package Exercises and solutions "],["keys.html", "13.3 Keys", " 13.3 Keys What is a key? A key is a variable (or set of variables) that uniquely identifies an observation. What is a relation? It is when a primary key and the corresponding foreign key in another table form a relation. What are the types of keys: A primary key uniquely identifies an observation in its own table. primary key: each row is an observation For example, planes$tailnum is a primary key because it uniquely identifies each plane in the planes table. A foreign key uniquely identifies an observation in another table. For example, flights$tailnum is a foreign key for the planes table because it appears in the flights table where it matches each flight to a unique plane. A surrogate key is a custom made key where it is possible to identify unique information, such as the number of rows in a table, and it is made if a table lacks a primary key. For example, flights$filghts_id is a surrogate key because it is custom made and uniquely identifies each observation in the flights table. Type of data relations 1-to-many: flight has one plane, but each plane has many flights Many-to-many: between airlines and airports, each airline flies to many airports; each airport hosts many airlines Special cases are: 1-to-1 and Many-to-1 "],["mutating-joins.html", "13.4 Mutating joins", " 13.4 Mutating joins To combine variables from two tables We have seen the inner_join() function operating now we see the other three outer joins: left_join() keeps all observations in x right_join() keeps all observations in y full_join() keeps all observations in x and y 13.4.1 Understanding joins Figure 13.2: Venn diagram Suppose we have two tables with two variables: id and the observations Figure 13.3: Two tables 13.4.2 Inner join flights %&gt;% slice(1:100) %&gt;% select(origin,year,month) %&gt;% inner_join(select(weather,origin,temp,wind_dir),by = &quot;origin&quot;) ## # A tibble: 870,507 √ó 5 ## origin year month temp wind_dir ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 2013 1 39.0 270 ## 2 EWR 2013 1 39.0 250 ## 3 EWR 2013 1 39.0 240 ## 4 EWR 2013 1 39.9 250 ## 5 EWR 2013 1 39.0 260 ## 6 EWR 2013 1 37.9 240 ## 7 EWR 2013 1 39.0 240 ## 8 EWR 2013 1 39.9 250 ## 9 EWR 2013 1 39.9 260 ## 10 EWR 2013 1 41 260 ## # ‚Ä¶ with 870,497 more rows Figure 13.4: inner join 13.4.3 Outer joins A left join keeps all observations in x A right join keeps all observations in y A full join keeps all observations in x and y (#fig:outerjoins.png)Outer joins left_join flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) %&gt;% select(-origin, -dest) %&gt;% left_join(airlines, by = &quot;carrier&quot;) ## # A tibble: 336,776 √ó 7 ## year month day hour tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 N619AA AA American Airlines Inc. ## 4 2013 1 1 5 N804JB B6 JetBlue Airways ## 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 N516JB B6 JetBlue Airways ## 8 2013 1 1 6 N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 N593JB B6 JetBlue Airways ## 10 2013 1 1 6 N3ALAA AA American Airlines Inc. ## # ‚Ä¶ with 336,766 more rows same thing with mutate() flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) %&gt;% select(-origin, -dest) %&gt;% mutate(name = airlines$name[match(carrier, airlines$carrier)]) ## # A tibble: 336,776 √ó 7 ## year month day hour tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 N619AA AA American Airlines Inc. ## 4 2013 1 1 5 N804JB B6 JetBlue Airways ## 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 N516JB B6 JetBlue Airways ## 8 2013 1 1 6 N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 N593JB B6 JetBlue Airways ## 10 2013 1 1 6 N3ALAA AA American Airlines Inc. ## # ‚Ä¶ with 336,766 more rows right_join weather %&gt;% select(origin,temp, humid, wind_dir, precip) %&gt;% right_join(airports, by = c(&quot;origin&quot; = &quot;faa&quot;)) ## # A tibble: 27,570 √ó 12 ## origin temp humid wind_dir precip name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 EWR 39.0 59.4 270 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 2 EWR 39.0 61.6 250 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 3 EWR 39.0 64.4 240 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 4 EWR 39.9 62.2 250 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 5 EWR 39.0 64.4 260 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 6 EWR 37.9 67.2 240 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 7 EWR 39.0 64.4 240 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 8 EWR 39.9 62.2 250 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 9 EWR 39.9 62.2 260 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## 10 EWR 41 59.6 260 0 Newar‚Ä¶ 40.7 -74.2 18 -5 A Amer‚Ä¶ ## # ‚Ä¶ with 27,560 more rows full_join airports %&gt;% select(name,lat,lon) %&gt;% full_join(airlines,by = &quot;name&quot;) ## # A tibble: 1,474 √ó 4 ## name lat lon carrier ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Lansdowne Airport 41.1 -80.6 &lt;NA&gt; ## 2 Moton Field Municipal Airport 32.5 -85.7 &lt;NA&gt; ## 3 Schaumburg Regional 42.0 -88.1 &lt;NA&gt; ## 4 Randall Airport 41.4 -74.4 &lt;NA&gt; ## 5 Jekyll Island Airport 31.1 -81.4 &lt;NA&gt; ## 6 Elizabethton Municipal Airport 36.4 -82.2 &lt;NA&gt; ## 7 Williams County Airport 41.5 -84.5 &lt;NA&gt; ## 8 Finger Lakes Regional Airport 42.9 -76.8 &lt;NA&gt; ## 9 Shoestring Aviation Airfield 39.8 -76.6 &lt;NA&gt; ## 10 Jefferson County Intl 48.1 -123. &lt;NA&gt; ## # ‚Ä¶ with 1,464 more rows 13.4.4 Duplicate keys What happens when the keys are not unique? Table with duplicates Figure 13.5: Duplicates Both tables have duplicate keys Figure 13.6: Duplicates 13.4.4.1 Defining the key columns by = \"key\" can be customized: by = NULL, uses all variables that appear in both tables (natural join) by = \"x\", uses only one specific variable by = c(\"a\" = \"b\"), uses a named character vector Exercises and solutions 13.4.4.2 Other implementations The base::merge() function can perform all four types of mutating join. The difference between the joins and merge() is really important. dplyr‚Äôs joins are considerably faster and don‚Äôt mess with the order of the rows. Figure 13.7: Implementations SQL is the inspiration for dplyr‚Äôs conventions Figure 13.8: Implementation Example of dplyr‚Äôs joins and SQL syntax: inner_join(x, y, by = c(&quot;a&quot; = &quot;b&quot;)) It uses a slightly different syntax in SQL: SELECT * FROM x INNER JOIN y ON x.a = y.b "],["filtering-joins.html", "13.5 Filtering joins", " 13.5 Filtering joins semi_join(x, y) keeps all observations in x that have a match in y. anti_join(x, y) drops all observations in x that have a match in y. Semi-join: semi_join() Figure 13.9: Semi-join top_dest &lt;- flights %&gt;% count(dest, sort = TRUE) %&gt;% head(10) flights %&gt;% semi_join(top_dest) # keeps all observations in x that have a match in y ## # A tibble: 141,145 √ó 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 542 540 2 923 850 ## 2 2013 1 1 554 600 -6 812 837 ## 3 2013 1 1 554 558 -4 740 728 ## 4 2013 1 1 555 600 -5 913 854 ## 5 2013 1 1 557 600 -3 838 846 ## 6 2013 1 1 558 600 -2 753 745 ## 7 2013 1 1 558 600 -2 924 917 ## 8 2013 1 1 558 600 -2 923 937 ## 9 2013 1 1 559 559 0 702 706 ## 10 2013 1 1 600 600 0 851 858 ## # ‚Ä¶ with 141,135 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Filtering joins never duplicate rows like mutating joins do: Figure 13.10: Semi-join The inverse of a semi-join is an anti-join: anti_join() flights %&gt;% anti_join(planes, by = &quot;tailnum&quot;) %&gt;% count(tailnum, sort = TRUE) # keeps the rows that don‚Äôt have a match ## # A tibble: 722 √ó 2 ## tailnum n ## &lt;chr&gt; &lt;int&gt; ## 1 &lt;NA&gt; 2512 ## 2 N725MQ 575 ## 3 N722MQ 513 ## 4 N723MQ 507 ## 5 N713MQ 483 ## 6 N735MQ 396 ## 7 N0EGMQ 371 ## 8 N534MQ 364 ## 9 N542MQ 363 ## 10 N531MQ 349 ## # ‚Ä¶ with 712 more rows Figure 13.11: Anti-join Exercises "],["some-more-things-to-consider.html", "13.6 Some more things to consider", " 13.6 Some more things to consider 13.6.1 Join problems Be aware that simply checking the number of rows before and after the join is not sufficient to ensure that your join has gone smoothly. Identifying the variables that form the primary key in each table Check for missing values Check that your foreign keys match primary keys in another table (using anti_join()`) 13.6.2 Set operations These are type of two-table verb set operations: intersect(x, y): return only observations in both x and y union(x, y): return unique observations in x and y setdiff(x, y): return observations in x, but not in y "],["strings.html", "Chapter 14 Strings", " Chapter 14 Strings Learning objectives: Manipulate character vectors using simple {stringr} functions. Use regular expressions (regex) to match patterns in strings. Use regex to match simple characters, ., and \\. Use regex ^, $, and \\b to match anchors and boundaries. Use regex \\d, \\s, [], and [^] to match character classes. Use regex | and () to match alternatives. Use regex ?, +, *, {n}, {n,}, {,m}, and {n, m} to match repetitions in patterns. Use regex grouping and backreferences to refer to previous matches. Use {stringr} functions and regex to manipulate strings. Detect pattern matches with stringr::str_detect(). Select subsets of strings that match a pattern with stringr::str_subset(). Count pattern matches with stringr::str_count(). Extract pattern matches with stringr::str_extract() and stringr::str_extract_all(). Extract group matches with stringr::str_match(), stringr::str_match_all(), and tidyr::extract(). Replace pattern matches with stringr::str_replace() and stringr::str_replace_all(). Split strings into pieces with stringr::str_split() and stringr::boundary(). Locate matches within a string with stringr::str_locate() and stringr::str_locate_all(). Use other {stringr} matching rules to find specific patterns. Use regex patterns with base functions such as apropos() and dir() to find things. Describe the relationship between {stringr} and {stringi}. "],["introduction-4.html", "14.1 Introduction", " 14.1 Introduction This chapter is going to be wicked fun!!! Regexs make up the backbone of textual searches. \"But can‚Äôt I just ctrl + f and search my document? Well, yes‚Ä¶but no‚Ä¶ Regular Expressions translate your search into computer code. stringr pkgdown site stringr cheatsheet 14.1.1 Pre-Requisites We will be utilizing the {stringr} package which is part of the core tidyverse. library(tidyverse) "],["string-basics.html", "14.2 String Basics", " 14.2 String Basics You can create strings with either single quotes ' or with double quotes \". The computer doesn‚Äôt care. However, which ever you choose, just stick with the format throughout your script. string1 &lt;- &#39;This is also a string, but uses single quotes&#39; string2 &lt;- &quot;This is a string with double quotes&quot; During scripting, if you do not close a string but try to start a new line you will see the + line entry. But how do you quit so you can add the closing quote? Just hit the escape key. &quot;This is a string, but I forgot to close the quote Help, I&#39;m stuck! (Hit the escape key) One of the more tricky things to remember when using regular expressions is the \\ backslash when you literally want to use a special character in a search. doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; print(doublequote) ## [1] &quot;\\&quot;&quot; print(singlequote) ## [1] &quot;&#39;&quot; Evaluating the above makes you question if my environment is correct. Yes it is. By printing to the screen, we are treating the output as a string‚Ä¶confused? To execute this as a regular expression however, we have to use writeLines(). doublequote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; singlequote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; writeLines(doublequote) ## &quot; writeLines(singlequote) ## &#39; There are a handful of other special characters. The most common are \\n, newline, and \\t, tab, but you can see the complete list by requesting help on : ?'\"', or ?\"'\". You‚Äôll also sometimes see strings like \\u00b5, this is a way of writing non-English characters that works on all platforms: x &lt;- &quot;\\u00b5&quot; x ## [1] &quot;¬µ&quot; y &lt;- &quot;\\U1F44D&quot; y ## [1] &quot;üëç&quot; Another way to think ‚Äúnon-English‚Äù would be to say these are Unicode values. NOTE: The list is quite extensive (~144K). A better way to state the comment, unicode is inteded to represent the worlds diverse linguistic and lexiconal attributes! Multiple strings are often stored in a character vector, which you can create with c(): c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; 14.2.1 String Length Base R has many functions that can work with String Length. Unfortunetely, these can all be a bit different. Therefore, we are going to use the {stringr} package to maintain our semantics and work within one package‚Ä¶{tidyverse}! All string functions in {stringr} start with the root str_ making use of the package quite intuitive. str_length(c(&quot;a&quot;, &quot;R for Data Science&quot;, NA)) ## [1] 1 18 NA Using the RStudio IDE makes using the autocomplete feature quiet simple This is a excellent way to quickly call on a particular {stringr} function! 14.2.2 Combining Strings To combine two or more strings, use str_c() str_c(&quot;x&quot;, &quot;y&quot;) ## [1] &quot;xy&quot; str_c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) ## [1] &quot;xyz&quot; You can also add the sep argument to control how the strings are seperated. str_c(&quot;x&quot;, &quot;y&quot;, sep = &quot;, &quot;) ## [1] &quot;x, y&quot; Like many other functions in R, if you have missing data, you can add NA. x &lt;- c(&quot;abc&quot;, NA) str_c(&quot;|-&quot;, x, &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; NA str_c(&quot;|-&quot;, str_replace_na(x), &quot;-|&quot;) ## [1] &quot;|-abc-|&quot; &quot;|-NA-|&quot; As shown above, str_c() is vectorised, and it automatically recycles shorter vectors to the same length as the longest: str_c(&quot;prefix-&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;-suffix&quot;) ## [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; I‚Äôm unsure if the use of recycle is accurate in the above statement. Another way to view this is a vector list inside a vector list. As the output is sent to the screen, the function acts like a for-loop inside a for-loop where each pass of the inside combination is iterated as combined with the outside combination iteration. Objects of length 0 are silently dropped. This is particularly useful in conjunction with if: name &lt;- &quot;Ryan&quot; time_of_day &lt;- &quot;afternon&quot; birthday &lt;- FALSE str_c( &quot;Good &quot;, time_of_day, &quot; &quot;, name, if (birthday) &quot; and HAPPY BIRTHDAY&quot;, &quot;.&quot; ) ## [1] &quot;Good afternon Ryan.&quot; The above example is written a bit confusing. The object birthday is passed as a boolean value of FALSE and therefore will never evaluate TRUE, making the if statement overhead. Maybe a better way to write the if statement would be to write an argument like sys.date == birthday in which case, if the system date of the computer matches the object birthday, you would get extra text. Finally, if you would like to collapse a vector of strings into a single string, use the collapse argument. str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), collapse = &quot;, &quot;) ## [1] &quot;x, y, z&quot; 14.2.3 Subsetting Strings You can extract parts of a string using str_sub(). As well as the string, str_sub() takes start and end arguments which give the (inclusive) position of the substring: x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, 1, 3) ## [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot; # negative numbers count backwards from end str_sub(x, -3, -1) ## [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot; Note that str_sub() won‚Äôt fail if the string is too short: it will just return as much as possible: str_sub(&quot;a&quot;, 1, 5) ## [1] &quot;a&quot; You can also use the assignment form of str_sub() to modify strings: str_sub(x, 1, 1) &lt;- str_to_lower(str_sub(x, 1, 1)) x ## [1] &quot;apple&quot; &quot;banana&quot; &quot;pear&quot; 14.2.4 Locales Alternatives to str_to_lower() is srr_to_upper() and str_to_title(). Changing case is a bit more complicated then it first appears Different languages have different rules for changing case # Turkish has two i&#39;s: with and without a dot, and it # has a different rule for capitalising them: str_to_upper(c(&quot;i&quot;, &quot;ƒ±&quot;)) ## [1] &quot;I&quot; &quot;I&quot; str_to_upper(c(&quot;i&quot;, &quot;ƒ±&quot;), locale = &quot;tr&quot;) ## [1] &quot;ƒ∞&quot; &quot;I&quot; Locale is specified as a ISO 639 language code, see Wikipedia Sorting and Order are also effected by Locale Base R only applies the system Locale Using {stringr} adds a local= argument x &lt;- c(&quot;apple&quot;, &quot;eggplant&quot;, &quot;banana&quot;) str_sort(x, locale = &quot;en&quot;) # English ## [1] &quot;apple&quot; &quot;banana&quot; &quot;eggplant&quot; str_sort(x, locale = &quot;haw&quot;) # Hawaiian ## [1] &quot;apple&quot; &quot;eggplant&quot; &quot;banana&quot; 14.2.5 Exercises In code that doesn‚Äôt use stringr, you‚Äôll often see paste() and paste0(). What‚Äôs the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA? paste() converts arguments to character strings and concatenates them. paste0() is the same function but slightly more efficent. The {stringr} they are equivelent to are str_c(). The major difference is the use of as.character() at its base versus {stingr}. The paste() and paste0() changes NA values to ‚ÄúNA‚Äù. In your own words, describe the difference between the sep and collapse arguments to str_c(). The sep argument treats each combined string as its own output. Whereas the collapse aregument creates one large string object. Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters? str_length() provides the quantity of characters in a string. str_sub() picks out the beginning and end of out of a vector. If the string has an even number of characters, it will only provide the smaller of the string. What does str_wrap() do? When might you want to use it? str_wrap() uses the Knuth-Plass paragraph wrapping algorithm. Knuth-Plass algorithm. This is important when using typesetting services like LaTeX. What does str_trim() do? What‚Äôs the opposite of str_trim()? str_trim() removes extra white space between vectorized strings. str_pad() is the opposite which puts characters back into the string. Write a function that turns (e.g.) a vector c(‚Äúa‚Äù, ‚Äúb‚Äù, ‚Äúc‚Äù) into the string a, b, and c.¬†Think carefully about what it should do if given a vector of length 0, 1, or 2. z &lt;- str_c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;, &quot;) z ## [1] &quot;a, b, c&quot; # Unsure on the second half of hte question. "],["matching-patterns-with-regular-expressions.html", "14.3 Matching Patterns with Regular Expressions", " 14.3 Matching Patterns with Regular Expressions To learn regular expressions (regexs) we‚Äôll use str_view() and str_view_all(). RegExplain 14.3.1 Basic Matches The simplest expressions are pattern matching: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;an&quot;) NOTE: If you run this locally, the window that opens looks empty. In truth, it is printed ‚Äúwhite‚Äù on ‚Äúwhite‚Äù and therefore hard to read. The next step up in complexity is ., which matches any character (except a newline): str_view(x, &quot;.a.&quot;) The trick here is if ‚Äú.‚Äù matches any character‚Ä¶what if we want to search for ‚Äú.‚Äù? We have to escape the term by using ‚Äú\\‚Äù. Yet‚Ä¶this leads to another problem. Since ‚Äú\\‚Äù is part of a string, we have to escape it twice. Therefore, it looks like this: ‚Äú\\\\.‚Äù. # To create the regular expression, we need \\\\ dot &lt;- &quot;\\\\.&quot; # But the expression itself only contains one: writeLines(dot) ## \\. #&gt; \\. # And this tells R to look for an explicit . str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;), &quot;a\\\\.c&quot;) Good, we figured out how to search for periods (.) by using the escape character \\. Ok, but what if we want to search for \\? Hmmmm‚Ä¶.we need to ‚Äúescape the escape‚Äù. HA! Therefore, we need four backslashes! ‚Äú\\\\\\\\‚Äù. x &lt;- &quot;a\\\\b&quot; writeLines(x) ## a\\b #&gt; a\\b str_view(x, &quot;\\\\\\\\&quot;) 14.3.1.1 Exercises Explain why each of these strings don‚Äôt match a \\: \"\\\", \"\\\\\", \"\\\\\\\". \\ doesn‚Äôt escape anything \"\\\" again, is a string and doesn‚Äôt escape anything \"\\\\\" escapes the escape, but doesn‚Äôt have any pattern to search for \"\\\\\\\" escapes the escape, but doesn‚Äôt finish the expression How would you match the sequence \"'\\? Unanswered What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string? Unanswered 14.3.2 Anchors By default, regular expressions will match anywhere in a string. However, if you want the beginning or end of a string, you can ‚Äúanchor‚Äù the regular expression. Lets see how this works: # The following matches anywhere &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a&quot;) Intesting, I thought when searching for ‚Äúa‚Äù, it would highlight every insteance of ‚Äúa‚Äù. So ‚Äúbanana‚Äù would hit three times. Nevermind‚Ä¶str_view_all() is required to list ALL instances of a search term. # The following matches only the beginning of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) # The following matches only the end of the string where &quot;a&quot; shows up x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) To remember which pattern to use, remember the mnemonic \"if you begin with power (^), you end up with money ($). Evan Misshula x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;apple&quot;) str_view(x, &quot;^apple$&quot;) 14.3.2.1 Exercise (Unanswered) How would you match the literal string ‚Äú$^$‚Äù? Given the corpus of common words in stringr::words, create regular expressions that find all words that: Start with ‚Äúy‚Äù. End with ‚Äúx‚Äù Are exactly three letters long. (Don‚Äôt cheat by using str_length()!) Have seven letters or more. Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words. 14.3.3 Character Classes and Alternatives There are a number of special patterns that match more than one character. - \\d: matches any digit. - \\s: matches any whitespace (e.g.¬†space, tab, newline). - [abc]: matches a, b, or c. - [^abc]: matches anything except a, b, or c. Remember, to create a regular expression containing \\d or \\s, you‚Äôll need to escape the \\ for the string, so you‚Äôll type ‚Äú\\\\d‚Äù or ‚Äú\\\\s‚Äù. # Look for a literal character that normally has special meaning in a regex str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[.]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;.[*]c&quot;) str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[ ]&quot;) This works for most (but not all) regex metacharacters: $ . | ? * + ( ) [ {. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: ] \\ ^ and -. You can also use alternation to pick between one or more alternative patterns. If precedence ever gets confusing, use parentheses to make it clear what you want: str_view(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr(e|a)y&quot;) 14.3.3.1 Exercise (Unanswered) Create regular expressions to find all words that: Start with a vowel. That only contain consonants. (Hint: thinking about matching ‚Äúnot‚Äù-vowels.) End with ed, but not with eed. End with ing or ise. Empirically verify the rule ‚Äúi before e except after c‚Äù. Is ‚Äúq‚Äù always followed by a ‚Äúu‚Äù? Write a regular expression that matches a word if it‚Äôs probably written in British English, not American English. Create a regular expression that will match telephone numbers as commonly written in your country. 14.3.4 Repetition Controlling how many time a pattern iterates is the next sequence of control. This can be accomplished with the following operators: ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;1888 is the longest year in Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;CC+&quot;) str_view(x, &#39;C[LX]+&#39;) The precedence of these operators is high which means most uses will need parentheses, like bana(na)+. You can also specify the number of matches precisely: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) By default, these form of searches are greedy, which matches the longest string possible. To make them lazy (searching for the shortest string), you can add ? at the end. str_view(x, &#39;C{2,3}?&#39;) str_view(x, &#39;C[LX]+?&#39;) 14.3.4.1 Exercises (Unanswered) Describe the equivalents of ?, +, * in {m,n} form. Describe in words what these regular expressions match: (read carefully to see if I‚Äôm using a regular expression or a string that defines a regular expression.) ^.*$ \"\\\\{.+\\\\}\" \\d{4}-\\d{2}-\\d{2} \"\\\\\\\\{4}\" Create regular expressions to find all words that: Start with three consonants. Have three or more vowels in a row. c.. Have two or more vowel-consonant pairs in a row. Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner. 14.3.5 Grouping and Backreferences Parentheses also create a numbered capturing group. A capturing group stores the part of the string matched by the part of the regular expression inside the parentheses -You can refer to the same text as previously matched by a capturing group with backreferences For example, the following regular expression finds all fruits that have a repeated pair of letters. str_view(fruit, &quot;(..)\\\\1&quot;, match = TRUE) Dumb question‚Ä¶how does the R Environment know the object fruit? Use the command data() in Console to see all listed datasets in BaseR as well as those included in your loaded packages. For example, fruit is a dataset included with {stringr}. 14.3.5.1 Exercises (Unanswered) Describe, in words, what these expressions will match: (.)\\1\\1 \"(.)(.)\\\\2\\\\1\" (..)\\1 \"(.).\\\\1.\\\\1\" \"(.)(.)(.).*\\\\3\\\\2\\\\1\" Construct regular expressions to match words that: Start and end with the same character. Contain a repeated pair of letters (e.g.¬†‚Äúchurch‚Äù contains ‚Äúch‚Äù repeated twice.) Contain one letter repeated in at least three places (e.g.¬†‚Äúeleven‚Äù contains three ‚Äúe‚Äùs.) "],["tools.html", "14.4 Tools", " 14.4 Tools In this section you‚Äôll learn a wide array of stringr functions that let you: Determine which strings match a pattern Find the positions of matches Extract the content of matches Replace matches with new values Split a string based on a match A word of caution before we continue: because regular expressions are so powerful, it‚Äôs easy to try and solve every problem with a single regular expression. In the words of Jamie Zawinski: Some people, when confronted with a problem, think ‚ÄúI know, I‚Äôll use regular expressions.‚Äù Now they have two problems. Exluded unbelievable long expression from presentation! Instead of creating one complex regular expression, it‚Äôs often easier to write a series of simpler regexs Quick story: I use regex at work to grep HTML for particular tags. Although I can do ctrl+f‚Ä¶I‚Äôd have to do it 1000s of times. Instead, I pass a recursive tag and iterate through the entire project. The process saves me HOURS! Break the problem down to smaller manageable chunks. Use a visual drawing if it helps to write out your expression. The point‚Ä¶don‚Äôt start from difficulty first! 14.4.1 Detect Matches To determine if a character vector matches a pattern, use str_detect(). It returns a logical vector the same length as the input: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;e&quot;) ## [1] TRUE FALSE TRUE The use of a boolean output (True/False) means, we can count them! TRUE = 1 FALSE = 0 Makind functions like sum() and mean() useful. # How many common words start with t? sum(str_detect(words, &quot;^t&quot;)) ## [1] 65 # What proportion of common words end with a vowel? mean(str_detect(words, &quot;[aeiou]$&quot;)) ## [1] 0.2765306 When you create large logical conditions, you may be able to break them down to simpler search terms and then combine them together. Always try to start simple. # Find all words containing at least one vowel, and negate no_vowels_1 &lt;- !str_detect(words, &quot;[aeiou]&quot;) # Find all words consisting only of consonants (non-vowels) no_vowels_2 &lt;- str_detect(words, &quot;^[^aeiou]+$&quot;) identical(no_vowels_1, no_vowels_2) ## [1] TRUE A common use of str_detect() is to match a pattern. You can do this with logical sub-setting or the convenient str_subset() wrapper: words[str_detect(words, &quot;x$&quot;)] ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; str_subset(words, &quot;x$&quot;) ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; NOTE, the first example‚Äôs syntax is foreign to me. Would any member like to express what is happening? Filter is another tool that can make string detection easier. df &lt;- tibble( word = words, i = seq_along(word) ) df %&gt;% filter(str_detect(word, &quot;x$&quot;)) ## # A tibble: 4 √ó 2 ## word i ## &lt;chr&gt; &lt;int&gt; ## 1 box 108 ## 2 sex 747 ## 3 six 772 ## 4 tax 841 A variation on str_detect() is str_count(): rather than a simple yes or no, it tells you how many matches there are in a string: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_count(x, &quot;a&quot;) ## [1] 1 3 1 # On average, how many vowels per word? mean(str_count(words, &quot;[aeiou]&quot;)) ## [1] 1.991837 It‚Äôs natural to use str_count() with mutate(): df %&gt;% mutate( vowels = str_count(word, &quot;[aeiou]&quot;), consonants = str_count(word, &quot;[^aeiou]&quot;) ) ## # A tibble: 980 √ó 4 ## word i vowels consonants ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 1 0 ## 2 able 2 2 2 ## 3 about 3 3 2 ## 4 absolute 4 4 4 ## 5 accept 5 2 4 ## 6 account 6 3 4 ## 7 achieve 7 4 3 ## 8 across 8 2 4 ## 9 act 9 1 2 ## 10 active 10 3 3 ## # ‚Ä¶ with 970 more rows Note that matches never overlap. For example, in ‚Äúabababa‚Äù, how many times will the pattern ‚Äúaba‚Äù match? Regular expressions say two, not three: str_count(&quot;abababa&quot;, &quot;aba&quot;) ## [1] 2 str_view_all(&quot;abababa&quot;, &quot;aba&quot;) Note the use of str_view_all(). As you‚Äôll shortly learn, many stringr functions come in pairs: one function works with a single match, and the other works with all matches. The second function will have the suffix _all. 14.4.1.1 Exercises (Unanswered) For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls. Find all words that start or end with x. Find all words that start with a vowel and end with a consonant. Are there any words that contain at least one of each different vowel? What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?) 14.4.2 Extract Matches Use str_extract() to extract the actual text of a match Harvard Sentences length(sentences) ## [1] 720 head(sentences) ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; ## [6] &quot;The juice of lemons makes fine punch.&quot; Imagine we want to find all sentences that contain a color. Note‚Ä¶I‚Äôm changing this section from the British English form colour to the American English form. Create a vector of color names Then turn it into a single regular expression colors &lt;- c(&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;) color_match &lt;- str_c(colors, collapse = &quot;|&quot;) color_match ## [1] &quot;red|orange|yellow|green|blue|purple&quot; Select the sentences that contain a color Extract the color to figure out which one it is has_color &lt;- str_subset(sentences, color_match) matches &lt;- str_extract(has_color, color_match) head(matches) ## [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;blue&quot; Note that str_extract() only extracts the first match. more &lt;- sentences[str_count(sentences, color_match) &gt; 1] str_view_all(more, color_match) str_extract(more, color_match) ## [1] &quot;blue&quot; &quot;green&quot; &quot;orange&quot; To get all matches, use str_extract_all(). str_extract_all(more, color_match) ## [[1]] ## [1] &quot;blue&quot; &quot;red&quot; ## ## [[2]] ## [1] &quot;green&quot; &quot;red&quot; ## ## [[3]] ## [1] &quot;orange&quot; &quot;red&quot; If you pass the argument simplify = TRUE, str_extract_all() will return a matrix with short matches expanded to the same length as the longest. str_extract_all(more, color_match, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;blue&quot; &quot;red&quot; ## [2,] &quot;green&quot; &quot;red&quot; ## [3,] &quot;orange&quot; &quot;red&quot; x &lt;- c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;) str_extract_all(x, &quot;[a-z]&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;a&quot; &quot;b&quot; &quot;&quot; ## [3,] &quot;a&quot; &quot;b&quot; &quot;c&quot; 14.4.2.1 Exercises (Unanswered) In the previous example, you might have noticed that the regular expression matched ‚Äúflickered‚Äù, which is not a colour. Modify the regex to fix the problem. From the Harvard sentences data, extract: The first word from each sentence. All words ending in ing. All plurals. 14.4.3 Grouped Matches Earlier we discussed using parentheses for clarifying precedence and for backreferences. ou can also use parentheses to extract parts of a complex match. noun &lt;- &quot;(a|the) ([^ ]+)&quot; has_noun &lt;- sentences %&gt;% str_subset(noun) %&gt;% head(10) has_noun %&gt;% str_extract(noun) ## [1] &quot;the smooth&quot; &quot;the sheet&quot; &quot;the depth&quot; &quot;a chicken&quot; &quot;the parked&quot; ## [6] &quot;the sun&quot; &quot;the huge&quot; &quot;the ball&quot; &quot;the woman&quot; &quot;a helps&quot; str_extract() gives us the complete match str_match() gives each individual component has_noun %&gt;% str_match(noun) ## [,1] [,2] [,3] ## [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; ## [2,] &quot;the sheet&quot; &quot;the&quot; &quot;sheet&quot; ## [3,] &quot;the depth&quot; &quot;the&quot; &quot;depth&quot; ## [4,] &quot;a chicken&quot; &quot;a&quot; &quot;chicken&quot; ## [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; ## [6,] &quot;the sun&quot; &quot;the&quot; &quot;sun&quot; ## [7,] &quot;the huge&quot; &quot;the&quot; &quot;huge&quot; ## [8,] &quot;the ball&quot; &quot;the&quot; &quot;ball&quot; ## [9,] &quot;the woman&quot; &quot;the&quot; &quot;woman&quot; ## [10,] &quot;a helps&quot; &quot;a&quot; &quot;helps&quot; (Unsurprisingly, our heuristic for detecting nouns is poor, and also picks up adjectives like smooth and parked.) If your data is in a tibble, it‚Äôs often easier to use tidyr::extract(). It works like str_match() but requires you to name the matches, which are then placed in new columns. tibble(sentence = sentences) %&gt;% tidyr::extract( sentence, c(&quot;article&quot;, &quot;noun&quot;), &quot;(a|the) ([^ ]+)&quot;, remove = FALSE ) ## # A tibble: 720 √ó 3 ## sentence article noun ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 The birch canoe slid on the smooth planks. the smooth ## 2 Glue the sheet to the dark blue background. the sheet ## 3 It&#39;s easy to tell the depth of a well. the depth ## 4 These days a chicken leg is a rare dish. a chicken ## 5 Rice is often served in round bowls. &lt;NA&gt; &lt;NA&gt; ## 6 The juice of lemons makes fine punch. &lt;NA&gt; &lt;NA&gt; ## 7 The box was thrown beside the parked truck. the parked ## 8 The hogs were fed chopped corn and garbage. &lt;NA&gt; &lt;NA&gt; ## 9 Four hours of steady work faced us. &lt;NA&gt; &lt;NA&gt; ## 10 Large size in stockings is hard to sell. &lt;NA&gt; &lt;NA&gt; ## # ‚Ä¶ with 710 more rows If you want all matches for each string, you‚Äôll need str_match_all() 14.4.3.1 Exercises (Unanswered) Find all words that come after a ‚Äúnumber‚Äù like ‚Äúone‚Äù, ‚Äútwo‚Äù, ‚Äúthree‚Äù etc. Pull out both the number and the word. Find all contractions. Separate out the pieces before and after the apostrophe. 14.4.4 Replacing Matches str_replace() and str_replace_all() allow you to replace matches with new strings. x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_replace(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-pple&quot; &quot;p-ar&quot; &quot;b-nana&quot; str_replace_all(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-ppl-&quot; &quot;p--r&quot; &quot;b-n-n-&quot; With str_replace_all() you can perform multiple replacements by supplying a named vector x &lt;- c(&quot;1 house&quot;, &quot;2 cars&quot;, &quot;3 people&quot;) str_replace_all(x, c(&quot;1&quot; = &quot;one&quot;, &quot;2&quot; = &quot;two&quot;, &quot;3&quot; = &quot;three&quot;)) ## [1] &quot;one house&quot; &quot;two cars&quot; &quot;three people&quot; Instead of replacing with a fixed string you can use backreferences to insert components of the match. sentences %&gt;% str_replace(&quot;([^ ]+) ([^ ]+) ([^ ]+)&quot;, &quot;\\\\1 \\\\3 \\\\2&quot;) %&gt;% head(5) ## [1] &quot;The canoe birch slid on the smooth planks.&quot; ## [2] &quot;Glue sheet the to the dark blue background.&quot; ## [3] &quot;It&#39;s to easy tell the depth of a well.&quot; ## [4] &quot;These a days chicken leg is a rare dish.&quot; ## [5] &quot;Rice often is served in round bowls.&quot; 14.4.4.1 Exercises (Unanswered) Replace all forward slashes in a string with backslashes. Implement a simple version of str_to_lower() using replace_all(). Switch the first and last letters in words. Which of those strings are still words? 14.4.5 Splitting Use str_split() to split a string up into pieces. sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; If you‚Äôre working with a length-1 vector, the easiest thing is to just extract the first element of the list. &quot;a|b|c|d&quot; %&gt;% str_split(&quot;\\\\|&quot;) %&gt;% .[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; You can use simplify = TRUE to return a matrix: sentences %&gt;% head(5) %&gt;% str_split(&quot; &quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; &quot;planks.&quot; ## [2,] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## [3,] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; ## [4,] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; &quot;rare&quot; ## [5,] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; &quot;&quot; ## [,9] ## [1,] &quot;&quot; ## [2,] &quot;&quot; ## [3,] &quot;well.&quot; ## [4,] &quot;dish.&quot; ## [5,] &quot;&quot; You can also request a maximum number of pieces fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;, n = 2, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Instead of splitting up strings by patterns, you can also split up by character, line, sentence and word boundary()s. x &lt;- &quot;This is a sentence. This is another sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_split(x, &quot; &quot;)[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence.&quot; &quot;&quot; &quot;This&quot; ## [7] &quot;is&quot; &quot;another&quot; &quot;sentence.&quot; str_split(x, boundary(&quot;word&quot;))[[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; &quot;This&quot; &quot;is&quot; &quot;another&quot; ## [8] &quot;sentence&quot; 14.4.5.1 Exercises (Unanswered) Split up a string like \"apples, pears, and bananas\" into individual components. Why is it better to split up by boundary(\"word\") than \" \"? What does splitting with an empty string (\"\") do? Experiment, and then read the documentation. 14.4.6 Find Matches str_locate() and str_locate_all() give you the starting and ending positions of each match. You can use str_locate() to find the matching pattern, str_sub() to extract and/or modify them. "],["other-types-of-pattern.html", "14.5 Other types of Pattern", " 14.5 Other types of Pattern When you use a pattern that‚Äôs a string, it‚Äôs automatically wrapped into a call to regex(). # The regular call: str_view(fruit, &quot;nana&quot;) # Is shorthand for str_view(fruit, regex(&quot;nana&quot;)) You can use the other arguments of regex() to control details of the match: ignore_case = TRUE allows characters to match either their uppercase or lowercase forms. This always uses the current locale. bananas &lt;- c(&quot;banana&quot;, &quot;Banana&quot;, &quot;BANANA&quot;) str_view(bananas, &quot;banana&quot;) str_view(bananas, regex(&quot;banana&quot;, ignore_case = TRUE)) multiline = TRUE allows ^ and $ to match the start and end of each line rather than the start and end of the complete string. x &lt;- &quot;Line 1\\nLine 2\\nLine 3&quot; str_extract_all(x, &quot;^Line&quot;)[[1]] ## [1] &quot;Line&quot; str_extract_all(x, regex(&quot;^Line&quot;, multiline = TRUE))[[1]] ## [1] &quot;Line&quot; &quot;Line&quot; &quot;Line&quot; comments = TRUE allows you to use comments and white space to make complex regular expressions more understandable. Spaces are ignored, as is everything after #. To match a literal space, you‚Äôll need to escape it: \"\\\\ \". phone &lt;- regex(&quot; \\\\(? # optional opening parens (\\\\d{3}) # area code [) -]? # optional closing parens, space, or dash (\\\\d{3}) # another three numbers [ -]? # optional space or dash (\\\\d{3}) # three more numbers &quot;, comments = TRUE) str_match(&quot;514-791-8141&quot;, phone) ## [,1] [,2] [,3] [,4] ## [1,] &quot;514-791-814&quot; &quot;514&quot; &quot;791&quot; &quot;814&quot; dotall = TRUE allows . to match everything, including \\n. There are three other functions you can use instead of regex(): fixed(): matches exactly the specified sequence of bytes. It ignores all special regular expressions and operates at a very low level. This allows you to avoid complex escaping and can be much faster than regular expressions. Note, I had to install the microbenchmark package before running the next code snippet. #install.packages(&quot;microbenchmark&quot;) library(microbenchmark) microbenchmark::microbenchmark( fixed = str_detect(sentences, fixed(&quot;the&quot;)), regex = str_detect(sentences, &quot;the&quot;), times = 20 ) ## Unit: microseconds ## expr min lq mean median uq max neval ## fixed 106.182 108.8025 128.6716 114.3680 117.4905 411.482 20 ## regex 376.013 378.3795 388.0852 379.2745 383.7405 471.091 20 Beware using fixed() with non-English data. It is problematic because there are often multiple ways of representing the same character. For example, there are two ways to define ‚Äú√°‚Äù: either as a single character or as an ‚Äúa‚Äù plus an accent: a1 &lt;- &quot;\\u00e1&quot; a2 &lt;- &quot;a\\u0301&quot; c(a1, a2) ## [1] &quot;√°&quot; &quot;aÃÅ&quot; a1 == a2 ## [1] FALSE They render identically, but because they‚Äôre defined differently, fixed() doesn‚Äôt find a match. Instead, you can use coll(), defined next, to respect human character comparison rules: str_detect(a1, fixed(a2)) ## [1] FALSE str_detect(a1, coll(a2)) ## [1] TRUE coll(): compare strings using standard collation rules. This is useful for doing case insensitive matching. Note that coll() takes a locale parameter that controls which rules are used for comparing characters. Unfortunately different parts of the world use different rules! # That means you also need to be aware of the difference # when doing case insensitive matches: i &lt;- c(&quot;I&quot;, &quot;ƒ∞&quot;, &quot;i&quot;, &quot;ƒ±&quot;) i ## [1] &quot;I&quot; &quot;ƒ∞&quot; &quot;i&quot; &quot;ƒ±&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE)) ## [1] &quot;I&quot; &quot;i&quot; str_subset(i, coll(&quot;i&quot;, ignore_case = TRUE, locale = &quot;tr&quot;)) ## [1] &quot;ƒ∞&quot; &quot;i&quot; Both fixed() and regex() have ignore_case arguments, but they do not allow you to pick the locale: they always use the default locale. stringi::stri_locale_info() ## $Language ## [1] &quot;en&quot; ## ## $Country ## [1] &quot;US&quot; ## ## $Variant ## [1] &quot;&quot; ## ## $Name ## [1] &quot;en_US&quot; The downside of coll() is speed; because the rules for recognising which characters are the same are complicated, coll() is relatively slow compared to regex() and fixed(). As you saw with str_split() you can use boundary() to match boundaries. You can also use it with the other functions: x &lt;- &quot;This is a sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_extract_all(x, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; 14.5.1 Exercises (Unanswered) How would you find all strings containing \\ with regex() vs.¬†with fixed()? What are the five most common words in sentences? "],["other-uses-of-regular-expressions.html", "14.6 Other uses of regular expressions", " 14.6 Other uses of regular expressions There are two useful function in base R that also use regular expressions: apropos() searches all objects available from the global environment. This is useful if you can‚Äôt quite remember the name of the function. apropos(&quot;replace&quot;) ## [1] &quot;%+replace%&quot; &quot;replace&quot; &quot;replace_na&quot; &quot;setReplaceMethod&quot; ## [5] &quot;str_replace&quot; &quot;str_replace_all&quot; &quot;str_replace_na&quot; &quot;theme_replace&quot; dir() lists all the files in a directory. The pattern argument takes a regular expression and only returns file names that match the pattern. head(dir(pattern = &quot;\\\\.Rmd$&quot;)) ## [1] &quot;01-preface.Rmd&quot; &quot;02-explore.Rmd&quot; ## [3] &quot;03-data_visualisation.Rmd&quot; &quot;04-workflow_basics.Rmd&quot; ## [5] &quot;05-data_transformation.Rmd&quot; &quot;06-workflow_scripts.Rmd&quot; If you‚Äôre more comfortable with ‚Äúglobs‚Äù like *.Rmd, you can convert them to regular expressions with glob2rx() "],["stringi.html", "14.7 stringi", " 14.7 stringi stringr is built on top of the stringi package. stringr is useful when you‚Äôre learning because it exposes a minimal set of functions, which have been carefully picked to handle the most common string manipulation functions. stringi, on the other hand, is designed to be comprehensive. It contains almost every function you might ever need: stringi has 250 functions to stringr‚Äôs 49. If you find yourself struggling to do something in stringr, it‚Äôs worth taking a look at stringi. The packages work very similarly, so you should be able to translate your stringr knowledge in a natural way. The main difference is the prefix: str_ vs.¬†stri_. 14.7.1 Exercises Find the stringi functions that: Count the number of words. Find duplicated strings. 3.Generate random text. How do you control the language that stri_sort() uses for sorting? "],["factors.html", "Chapter 15 Factors", " Chapter 15 Factors Learning objectives: Create factor() variables. Explore the General Social Survey dataset via forcats::gss_cat. Reorder factor levels. forcats::fct_reorder() forcats::fct_relevel() forcats::fct_reorder2() forcats::fct_infreq() forcats::fct_rev() Modify factor levels. forcats::fct_recode() forcats::fct_collapse() forcats::fct_lump() "],["slide-1-4.html", "15.1 Slide 1", " 15.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-4.html", "15.2 Slide 2", " 15.2 Slide 2 Slide contents. "],["dates-and-times.html", "Chapter 16 Dates and times", " Chapter 16 Dates and times Learning objectives: Create date and datetime objects. Create dates and datetimes from strings. Create dates and datetimes from individual components. Create dates and datetimes from each other. Work with datetime components. Extract components from datetimes. Round datetime components. Set individual datetime components. Perform arithmetic on timespans. Use durations to measure exact seconds. Use periods to measure human units like weeks and months. Use intervals to represent timespans with exact start and end datetimes. Recognize ways to deal with timezones in R. "],["slide-1-5.html", "16.1 Slide 1", " 16.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-5.html", "16.2 Slide 2", " 16.2 Slide 2 Slide contents. "],["introduction-5.html", "Chapter 17 Introduction", " Chapter 17 Introduction Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-6.html", "17.1 Slide 1", " 17.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-6.html", "17.2 Slide 2", " 17.2 Slide 2 Slide contents. "],["pipes.html", "Chapter 18 Pipes", " Chapter 18 Pipes Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-7.html", "18.1 Slide 1", " 18.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-7.html", "18.2 Slide 2", " 18.2 Slide 2 Slide contents. "],["functions-2.html", "Chapter 19 Functions", " Chapter 19 Functions Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-8.html", "19.1 Slide 1", " 19.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-8.html", "19.2 Slide 2", " 19.2 Slide 2 Slide contents. "],["vectors.html", "Chapter 20 Vectors", " Chapter 20 Vectors Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-9.html", "20.1 Slide 1", " 20.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-9.html", "20.2 Slide 2", " 20.2 Slide 2 Slide contents. "],["iteration.html", "Chapter 21 Iteration", " Chapter 21 Iteration Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-10.html", "21.1 Slide 1", " 21.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-10.html", "21.2 Slide 2", " 21.2 Slide 2 Slide contents. "],["introduction-6.html", "Chapter 22 Introduction", " Chapter 22 Introduction Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-11.html", "22.1 Slide 1", " 22.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-11.html", "22.2 Slide 2", " 22.2 Slide 2 Slide contents. "],["model-basics.html", "Chapter 23 Model basics", " Chapter 23 Model basics Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-12.html", "23.1 Slide 1", " 23.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-12.html", "23.2 Slide 2", " 23.2 Slide 2 Slide contents. "],["model-building.html", "Chapter 24 Model building", " Chapter 24 Model building Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-13.html", "24.1 Slide 1", " 24.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-13.html", "24.2 Slide 2", " 24.2 Slide 2 Slide contents. "],["many-models.html", "Chapter 25 Many models", " Chapter 25 Many models Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-14.html", "25.1 Slide 1", " 25.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-14.html", "25.2 Slide 2", " 25.2 Slide 2 Slide contents. "],["introduction-7.html", "Chapter 26 Introduction", " Chapter 26 Introduction Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-15.html", "26.1 Slide 1", " 26.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-15.html", "26.2 Slide 2", " 26.2 Slide 2 Slide contents. "],["r-markdown.html", "Chapter 27 R Markdown", " Chapter 27 R Markdown Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-16.html", "27.1 Slide 1", " 27.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-16.html", "27.2 Slide 2", " 27.2 Slide 2 Slide contents. "],["graphics-for-communication.html", "Chapter 28 Graphics for communication", " Chapter 28 Graphics for communication Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-17.html", "28.1 Slide 1", " 28.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-17.html", "28.2 Slide 2", " 28.2 Slide 2 Slide contents. "],["r-markdown-formats.html", "Chapter 29 R Markdown formats", " Chapter 29 R Markdown formats Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-18.html", "29.1 Slide 1", " 29.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-18.html", "29.2 Slide 2", " 29.2 Slide 2 Slide contents. "],["r-markdown-workflow.html", "Chapter 30 R Markdown workflow", " Chapter 30 R Markdown workflow Learning objectives: Jon will try to prefill these ahead of each week. "],["slide-1-19.html", "30.1 Slide 1", " 30.1 Slide 1 Slide contents. Keep it short and slide-like! "],["slide-2-19.html", "30.2 Slide 2", " 30.2 Slide 2 Slide contents. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
